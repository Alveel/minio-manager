{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"minio-manager","text":"<p>Declare what MinIO buckets, IAM policies, ILM policies you want, and let MinIO Manager do the work.</p>"},{"location":"modules/","title":"Modules","text":"<p>ClusterResources is the object containing all the cluster resources:</p> <ul> <li>buckets</li> <li>bucket_policies</li> <li>service_accounts</li> <li>iam_policies</li> <li>iam_policy_attachments</li> </ul> Source code in <code>minio_manager/classes/config.py</code> <pre><code>class ClusterResources:\n    \"\"\"ClusterResources is the object containing all the cluster resources:\n\n    - buckets\n    - bucket_policies\n    - service_accounts\n    - iam_policies\n    - iam_policy_attachments\n    \"\"\"\n\n    buckets: list[Bucket]\n    bucket_policies: list[BucketPolicy]\n    service_accounts: list[ServiceAccount]\n    iam_policies: list[IamPolicy]\n    iam_policy_attachments: list[IamPolicyAttachment]\n\n    def parse_buckets(self, buckets: list[dict]) -&gt; list[Bucket]:\n        \"\"\"Parse the provided buckets with the following steps:\n        For each provided bucket\n            1. check the provided versioning. If versioning is not provided, set the default.\n            2. check if an object lifecycle JSON file is provided, use the default_bucket_lifecycle_policy, or skip OLM\n            3. parse the file and create a LifecycleConfig object for the bucket\n            4. create a Bucket object\n\n        Args:\n            buckets: list of buckets to parse\n\n        Returns:\n            [Bucket]: list of Bucket objects\n        \"\"\"\n        if not buckets:\n            logger.info(\"No buckets configured, skipping.\")\n            return []\n\n        bucket_objects = []\n        if not isinstance(buckets, list):\n            logger.error(\"buckets must be defined as a list!\")\n            sys.exit(1)\n\n        lifecycle_config = self.parse_bucket_lifecycle_file(default_bucket_lifecycle_policy)\n        bucket_names = []\n\n        for bucket in buckets:\n            name = bucket[\"name\"]\n            if name in bucket_names:\n                logger.error(f\"Bucket '{name}' defined multiple times. Stopping.\")\n                sys.exit(1)\n            bucket_names.append(name)\n            logger.debug(f\"Parsing bucket {name}\")\n            if not name.startswith(default_bucket_allowed_prefix):\n                logger.error(f\"Bucket {name} does not start with required prefix '{default_bucket_allowed_prefix}'.\")\n                sys.exit(1)\n\n            versioning = bucket.get(\"versioning\")\n            try:\n                versioning_config = VeCo(versioning) if versioning else VeCo(default_bucket_versioning)\n            except ValueError as ve:\n                logger.error(f\"Error parsing versioning setting: {' '.join(ve.args)}\")\n                sys.exit(1)\n            create_sa = bool(bucket.get(\"create_service_account\", default_bucket_create_service_account))\n            lifecycle_file = bucket.get(\"object_lifecycle_file\")\n            if lifecycle_file:\n                bucket_lifecycle = self.parse_bucket_lifecycle_file(lifecycle_file)\n                if isinstance(bucket_lifecycle, LifecycleConfig):\n                    lifecycle_config = bucket_lifecycle\n            bucket_objects.append(Bucket(name, create_sa, versioning_config, lifecycle_config))\n\n        return bucket_objects\n\n    def parse_bucket_lifecycle_file(self, lifecycle_file: str) -&gt; LifecycleConfig | None:\n        \"\"\"Parse a bucket lifecycle config file.\n        The config files must be in JSON format and can be best obtained by running the following command:\n            mc ilm rule export $cluster/$bucket &gt; $policy_file.json\n\n        Args:\n            lifecycle_file: lifecycle config file\n\n        Returns:\n            LifecycleConfig object\n        \"\"\"\n        if not lifecycle_file:\n            return\n\n        rules: list = []\n\n        try:\n            with Path(lifecycle_file).open() as f:\n                config_data = json.load(f)\n        except FileNotFoundError:\n            logger.error(f\"Lifecycle file {lifecycle_file} not found, skipping configuration.\")\n            sys.exit(1)\n        except PermissionError:\n            logger.error(f\"Incorrect file permissions on {lifecycle_file}, skipping configuration.\")\n            sys.exit(1)\n\n        try:\n            rules_dict = config_data[\"Rules\"]\n        except KeyError:\n            logger.error(f\"Lifecycle file {lifecycle_file} is missing the required 'Rules' key.\")\n            sys.exit(1)\n        try:\n            for rule_data in rules_dict:\n                parsed_rule = self.parse_bucket_lifecycle_rule(rule_data)\n                rules.append(parsed_rule)\n        except AttributeError:\n            logger.error(f\"Error parsing lifecycle file {lifecycle_file}. Is the format correct?\")\n            sys.exit(1)\n\n        if not rules:\n            return\n\n        return LifecycleConfig(rules)\n\n    @staticmethod\n    def parse_bucket_lifecycle_rule(rule_data: dict) -&gt; Rule:\n        \"\"\"Parse a single bucket object lifecycle rule\n        TODO: implement date and days in Expiration, implement Transition, NoncurrentVersionTransition, Filter, and\n          AbortIncompleteMultipartUpload\n\n        Args:\n            rule_data: dict with rule data\n\n        Returns:\n            Rule\n        \"\"\"\n        rule_dict = {\"status\": rule_data.get(\"Status\"), \"rule_id\": rule_data.get(\"ID\")}\n\n        expiration = rule_data.get(\"Expiration\")\n        if expiration:\n            expire_delete_marker = expiration.get(\"ExpiredObjectDeleteMarker\")\n            rule_dict[\"expiration\"] = Expiration(expired_object_delete_marker=expire_delete_marker)\n\n        noncurrent_version_expiration = rule_data.get(\"NoncurrentVersionExpiration\")\n        if noncurrent_version_expiration:\n            noncurrent_expire_days = noncurrent_version_expiration.get(\"NoncurrentDays\")\n            rule_dict[\"noncurrent_version_expiration\"] = NoncurrentVersionExpiration(noncurrent_expire_days)\n\n        # An empty filter is required for the rule to be valid\n        rule_dict[\"rule_filter\"] = Filter(prefix=\"\")\n\n        rule = Rule(**rule_dict)\n        return rule\n\n    @staticmethod\n    def parse_bucket_policies(bucket_policies):\n        if not bucket_policies:\n            logger.info(\"No bucket policies configured, skipping.\")\n            return []\n\n        bucket_policy_objects = []\n        for bucket_policy in bucket_policies:\n            bucket_policy_objects.append(BucketPolicy(bucket_policy[\"bucket\"], bucket_policy[\"policy_file\"]))\n\n        return bucket_policy_objects\n\n    @staticmethod\n    def parse_service_accounts(service_accounts):\n        if not service_accounts:\n            logger.info(\"No service accounts configured, skipping.\")\n            return []\n\n        service_account_objects, service_account_names = [], []\n        for service_account in service_accounts:\n            name = service_account[\"name\"]\n            if name in service_account_names:\n                logger.error(f\"Service account '{name}' defined multiple times. Stopping.\")\n                sys.exit(1)\n            service_account_names.append(name)\n            policy_file = service_account.get(\"policy_file\")\n            sa_obj = ServiceAccount(name=name, policy_file=policy_file)\n            service_account_objects.append(sa_obj)\n\n        return service_account_objects\n\n    @staticmethod\n    def parse_iam_attachments(iam_policy_attachments):\n        if not iam_policy_attachments:\n            logger.info(\"No IAM policy attachments configured, skipping.\")\n            return []\n\n        iam_policy_attachment_objects = []\n        for user in iam_policy_attachments:\n            iam_policy_attachments.append(IamPolicyAttachment(user[\"username\"], user[\"policies\"]))\n\n        return iam_policy_attachment_objects\n\n    @staticmethod\n    def parse_iam_policies(iam_policies):\n        if not iam_policies:\n            logger.info(\"No IAM policies configured, skipping.\")\n            return []\n\n        iam_policy_objects, iam_policy_names = [], []\n        for iam_policy in iam_policies:\n            name = iam_policy[\"name\"]\n            if name in iam_policy_names:\n                logger.error(f\"IAM policy '{name}' defined multiple times. Stopping.\")\n                sys.exit(1)\n            iam_policy_names.append(name)\n            iam_policy_objects.append(IamPolicy(name, iam_policy[\"policy_file\"]))\n\n        return iam_policy_objects\n\n    def parse_resources(self, resources_file: str):\n        try:\n            resources = read_yaml(resources_file)\n        except FileNotFoundError:\n            logger.error(f\"Resources file {resources_file} not found. Stopping.\")\n            sys.exit(1)\n        except PermissionError:\n            logger.error(f\"Incorrect file permissions on {resources_file}. Stopping.\")\n            sys.exit(1)\n\n        buckets = resources.get(\"buckets\")\n        self.buckets = self.parse_buckets(buckets)\n\n        bucket_policies = resources.get(\"bucket_policies\")\n        self.bucket_policies = self.parse_bucket_policies(bucket_policies)\n\n        service_accounts = resources.get(\"service_accounts\")\n        self.service_accounts = self.parse_service_accounts(service_accounts)\n\n        iam_policies = resources.get(\"iam_policies\")\n        self.iam_policies = self.parse_iam_policies(iam_policies)\n\n        iam_policy_attachments = resources.get(\"iam_policy_attachments\")\n        self.iam_policy_attachments = self.parse_iam_attachments(iam_policy_attachments)\n</code></pre> <p>MinioConfig is the MinIO server configuration object containing the connection details.</p> Source code in <code>minio_manager/classes/config.py</code> <pre><code>class MinioConfig:\n    \"\"\"MinioConfig is the MinIO server configuration object containing the connection details.\"\"\"\n\n    def __init__(self):\n        self.name = get_env_var(\"MINIO_MANAGER_CLUSTER_NAME\")\n        self.endpoint = get_env_var(\"MINIO_MANAGER_S3_ENDPOINT\")\n        self.secure = get_env_var(\"MINIO_MANAGER_S3_ENDPOINT_SECURE\", True)\n        self.controller_user = get_env_var(\"MINIO_MANAGER_MINIO_CONTROLLER_USER\")\n        self.access_key = None\n        self.secret_key = None\n        self.cluster_resources = get_env_var(\"MINIO_MANAGER_CLUSTER_RESOURCES_FILE\", \"resources.yaml\")\n        self.secret_backend_type = get_env_var(\"MINIO_MANAGER_SECRET_BACKEND_TYPE\")\n        self.secret_s3_bucket = get_env_var(\"MINIO_MANAGER_SECRET_BACKEND_S3_BUCKET\", \"minio-manager-secrets\")\n</code></pre> <p>             Bases: <code>Exception</code></p> <p>Base class for Minio Manager errors.</p> Source code in <code>minio_manager/classes/errors.py</code> <pre><code>class MinioManagerBaseError(Exception):\n    \"\"\"Base class for Minio Manager errors.\"\"\"\n\n    def __init__(self, message: str, cause=None):\n        super().__init__(f\"{message}: {cause}\" if cause else message)\n</code></pre> <p>             Bases: <code>Filter</code></p> Source code in <code>minio_manager/classes/logging_config.py</code> <pre><code>class MinioManagerFilter(Filter):\n    wrapper_secret_re = re.compile(r\"--secret-key (?P&lt;secret&gt;[\\w+/]*)\")\n    alias_set_secret_re = re.compile(r\"alias set .+ (?P&lt;secret&gt;[\\w+/]*)$\")\n\n    def filter(self, record: LogRecord) -&gt; bool:\n        if \"--secret\" in record.msg:\n            record.msg = self.mask_secret(record.msg, self.wrapper_secret_re)\n        if \"alias set\" in record.msg:\n            record.msg = self.mask_secret(record.msg, self.alias_set_secret_re)\n\n        return True\n\n    @staticmethod\n    def mask_secret(message: str, regex: re.Pattern) -&gt; str:\n        result = regex.search(message)\n        if result:\n            message = message.replace(result.group(\"secret\"), \"************\")\n        return message\n</code></pre> <p>             Bases: <code>Formatter</code></p> Source code in <code>minio_manager/classes/logging_config.py</code> <pre><code>class MinioManagerFormatter(Formatter):\n    def __init__(self, log_level: int):\n        self.log_level = log_level\n        if log_level is logging.INFO:\n            log_format = \"[{asctime}] [{levelname:^8s}] {message}\"\n            super().__init__(fmt=log_format, datefmt=\"%Y-%m-%d %H:%M:%S\", style=\"{\")\n        else:\n            log_format = \"[{asctime}] [{levelname:^8s}] [{filename:&gt;26s}:{lineno:&lt;4d} - {funcName:&lt;24s} ] {message}\"\n            super().__init__(fmt=log_format, style=\"{\")\n\n    def format(self, record: LogRecord):  # noqa: A003\n        if record.levelname in COLORS:\n            record.msg = COLORS[record.levelname] + record.msg + RESET\n            # record.levelname = COLORS[record.levelname] + record.levelname + RESET\n\n        return super().format(record)\n</code></pre> <p>             Bases: <code>Logger</code></p> Source code in <code>minio_manager/classes/logging_config.py</code> <pre><code>class MinioManagerLogger(logging.Logger):\n    def __init__(self, name: str, log_level: str):\n        super().__init__(name)\n        if log_level == \"INFO\":\n            self.setLevel(logging.INFO)\n        else:\n            self.setLevel(logging.DEBUG)\n\n        handler = logging.StreamHandler()\n        formatter = MinioManagerFormatter(self.level)\n        this_filter = MinioManagerFilter()\n        handler.setFormatter(formatter)\n        handler.addFilter(this_filter)\n        self.addHandler(handler)\n</code></pre> Source code in <code>minio_manager/classes/mc_wrapper.py</code> <pre><code>class McWrapper:\n    def __init__(self, config: MinioConfig, timeout=60):\n        logger.debug(\"Initialising McWrapper\")\n        self.cluster_name = config.name\n        self.cluster_controller_user = config.controller_user\n        self.timeout = timeout\n        self.mc_config_path = self.set_config_path()\n        self.mc = self.find_mc_command()\n        self.configure(config.endpoint, config.access_key, config.secret_key, config.secure)\n        logger.debug(\"McWrapper initialised\")\n\n    def _run(self, args, multiline=False) -&gt; list[dict] | dict:\n        \"\"\"Execute mc command and return JSON output.\"\"\"\n        logger.debug(f\"Running: {self.mc} --json {' '.join(args)}\")\n        proc = subprocess.run(\n            [self.mc, \"--json\", *args],  # noqa: S603\n            capture_output=True,\n            timeout=self.timeout,\n            text=True,\n        )\n        if not proc.stdout:\n            return [] if multiline else {}\n        if multiline:\n            return [json.loads(line) for line in proc.stdout.splitlines()]\n        return json.loads(proc.stdout)\n\n    @staticmethod\n    def set_config_path():\n        \"\"\"Set the path to the mc config.json file\"\"\"\n        env_mc_config_path = os.getenv(\"MC_CONFIG_PATH\")\n        env_home = os.getenv(\"HOME\")\n        mc_paths = [\n            f\"{env_mc_config_path}/config.json\",\n            f\"{env_home}/.mc/config.json\",\n            f\"{env_home}/.mcli/config.json\",\n        ]\n        for path in mc_paths:\n            if os.path.exists(path):\n                return path\n\n    @staticmethod\n    def find_mc_command() -&gt; Path:\n        \"\"\"Configure the path to the mc command, as it may be named 'mcli' on some systems.\"\"\"\n        mc = shutil.which(\"mc\")\n        if not mc:\n            mc = shutil.which(\"mcli\")\n        return Path(mc)\n\n    def configure(self, endpoint, access_key, secret_key, secure: bool):\n        \"\"\"Ensure the proper alias is configured for the cluster.\"\"\"\n        logger.debug(f\"Validating config for cluster {self.cluster_name}\")\n        cluster_ready = self._run([\"ready\", self.cluster_name])\n        logger.debug(f\"Cluster status: {cluster_ready}\")\n        error = cluster_ready.get(\"error\")\n        if not error:\n            # Cluster is configured &amp; available\n            return\n\n        logger.info(\"Endpoint is not configured or erroneous, configuring...\")\n        url = f\"https://{endpoint}\" if secure else f\"http://{endpoint}\"\n        alias_set_resp = self._run([\"alias\", \"set\", self.cluster_name, url, access_key, secret_key])\n        if alias_set_resp.get(\"error\"):\n            error_details = alias_set_resp[\"error\"][\"cause\"][\"error\"]\n            try:\n                raise_specific_error(error_details[\"Code\"], error_details[\"Message\"])\n            except AttributeError as ae:\n                logger.exception(\"Unknown error!\")\n                raise MinioManagerBaseError(alias_set_resp[\"error\"][\"cause\"][\"message\"]) from ae\n\n        cluster_ready = self._run([\"ready\", self.cluster_name])\n        healthy = cluster_ready.get(\"healthy\")\n        if healthy:\n            # Cluster is configured &amp; available\n            return\n\n        if cluster_ready.get(\"error\"):\n            # A connection error occurred\n            raise ConnectionError(cluster_ready[\"error\"])\n\n    def _service_account_run(self, cmd, args):\n        \"\"\"\n        mc admin user svcacct helper function, no need to specify the cluster name\n        Args:\n            cmd: str, the svcacct command\n            args: list of arguments to the command\n\n        Returns: a SimpleNamespace object\n\n        \"\"\"\n        multiline = cmd in [\"list\", \"ls\"]\n        resp = self._run([\"admin\", \"user\", \"svcacct\", cmd, self.cluster_name, *args], multiline=multiline)\n        resp_error = resp[0] if multiline else resp\n        if hasattr(resp_error, \"error\"):\n            resp_error = resp_error[\"error\"]\n            error_details = resp_error[\"cause\"][\"error\"]\n            raise_specific_error(error_details[\"Code\"], error_details[\"Message\"])\n        return resp\n\n    def service_account_add(self, credentials: ServiceAccount) -&gt; ServiceAccount:\n        \"\"\"\n        mc admin user svcacct add alias-name 'username' --name \"sa-test-key\"\n\n        Args:\n            credentials (ServiceAccount): object containing at least the user-friendly name of the service account\n\n        Returns: ServiceAccount with the access and secret keys added to it\n        \"\"\"\n        # Create the service account in MinIO\n        args = [self.cluster_controller_user, \"--name\", credentials.name]\n        if credentials.description:\n            args.extend([\"--description\", credentials.description])\n        if credentials.secret_key:\n            args.extend([\"--secret-key\", credentials.secret_key])\n        if credentials.access_key:\n            args.extend([\"--access-key\", credentials.access_key])\n        resp = self._service_account_run(\"add\", args)\n        credentials.access_key = resp[\"accessKey\"]\n        credentials.secret_key = resp[\"secretKey\"]\n        return credentials\n\n    def service_account_list(self, access_key) -&gt; list[dict]:\n        \"\"\"mc admin user svcacct ls alias-name 'access_key'\"\"\"\n        return self._service_account_run(\"ls\", [access_key])\n\n    def service_account_info(self, access_key) -&gt; dict:\n        \"\"\"mc admin user svcacct info alias-name service-account-access-key\"\"\"\n        return self._service_account_run(\"info\", [access_key])\n\n    def service_account_delete(self):\n        \"\"\"mc admin user svcacct rm alias-name service-account-access-key\"\"\"\n        raise NotImplementedError\n\n    def service_account_get_policy(self, access_key) -&gt; dict:\n        info = self.service_account_info(access_key)\n        return info[\"policy\"]\n\n    def service_account_set_policy(self, access_key: str, policy_file: str):\n        \"\"\"mc admin user svcacct edit alias-name service-account-access-key --policy policy-file\"\"\"\n        return self._service_account_run(\"edit\", [access_key, \"--policy\", policy_file])\n</code></pre> Source code in <code>minio_manager/classes/minio_resources.py</code> <pre><code>class Bucket:\n    def __init__(\n        self,\n        name: str,\n        create_service_account: bool = True,\n        versioning: VersioningConfig | None = None,\n        lifecycle_config: LifecycleConfig | None = None,\n    ):\n        self.name = name\n        self.create_sa = create_service_account\n        self.versioning = versioning\n        self.lifecycle_config = lifecycle_config\n</code></pre> Source code in <code>minio_manager/classes/minio_resources.py</code> <pre><code>class BucketPolicy:\n    # TODO: try loading the policy file in order to validate its contents\n    def __init__(self, bucket: str, policy_file: str):\n        self.bucket = bucket\n        self.policy_file = policy_file\n</code></pre> Source code in <code>minio_manager/classes/minio_resources.py</code> <pre><code>class ServiceAccount:\n    policy = ClassVar[dict]\n\n    def __init__(\n        self,\n        name: str,\n        description: str = \"\",\n        access_key: str | None = None,\n        secret_key: str | None = None,\n        policy: dict | None = None,\n        policy_file: Path | str | None = None,\n    ):\n        if len(name) &gt; 32:\n            self.name = name[:32]\n            self.description = name + \" \" + description\n        else:\n            self.name = name\n            self.description = description\n        self.access_key = access_key\n        self.secret_key = secret_key\n        if policy_file:\n            if isinstance(policy_file, Path):\n                self.policy_file = policy_file\n            else:\n                self.policy_file = Path(policy_file)\n        else:\n            self.policy_file = None\n        if policy:\n            self.policy = policy\n        elif self.policy_file:\n            try:\n                self.policy = read_json(self.policy_file)\n            except FileNotFoundError:\n                logger.critical(f\"Policy file '{self.policy_file}' for service account '{name}' not found!\")\n                sys.exit(1)\n\n    def generate_service_account_policy(self):\n        \"\"\"\n        Generate a policy for a service account that gives access to a bucket with the same name as the service account.\n        \"\"\"\n        with Path(sa_policy_base_file).open() as base:\n            base_policy = base.read()\n\n        temp_file = NamedTemporaryFile(prefix=self.name, suffix=\".json\", delete=False)\n        with temp_file as out:\n            new_content = base_policy.replace(\"BUCKET_NAME_REPLACE_ME\", self.name)\n            out.write(new_content.encode(\"utf-8\"))\n\n        self.policy = json.loads(new_content)\n        self.policy_file = Path(temp_file.name)\n</code></pre> Source code in <code>minio_manager/classes/minio_resources.py</code> <pre><code>class IamPolicy:\n    def __init__(self, name: str, policy_file: str):\n        self.name = name\n        self.policy_file = policy_file\n</code></pre> Source code in <code>minio_manager/classes/minio_resources.py</code> <pre><code>class IamPolicyAttachment:\n    def __init__(self, username: str, policies: list):\n        self.username = username\n        self.policies = policies\n</code></pre> <p>SecretManager is responsible for managing credentials</p> Source code in <code>minio_manager/classes/secrets.py</code> <pre><code>class SecretManager:\n    \"\"\"SecretManager is responsible for managing credentials\"\"\"\n\n    def __init__(self, config: MinioConfig):\n        logger.debug(\"Initialising SecretManager\")\n        self._cluster_name = config.name\n        self.backend_dirty = False\n        self.backend_type = config.secret_backend_type\n        self.backend_bucket = config.secret_s3_bucket\n        self.backend_secure = config.secure\n        self.backend_filename = None\n        self.keepass_temp_file_name = None\n        self.keepass_group = None\n        self.backend_s3 = self.setup_backend_s3()\n        self.backend = self.setup_backend()\n        logger.info(f\"Secret backend initialised with {self.backend_type}\")\n\n    def setup_backend_s3(self):\n        endpoint = get_env_var(\"MINIO_MANAGER_S3_ENDPOINT\")\n        access_key = get_env_var(\"MINIO_MANAGER_SECRET_BACKEND_S3_ACCESS_KEY\")\n        secret_key = get_env_var(\"MINIO_MANAGER_SECRET_BACKEND_S3_SECRET_KEY\")\n        logger.debug(f\"Setting up secret bucket {self.backend_bucket}\")\n        s3 = Minio(endpoint=endpoint, access_key=access_key, secret_key=secret_key, secure=self.backend_secure)\n        try:\n            s3.bucket_exists(self.backend_bucket)\n        except S3Error as s3e:\n            if s3e.code == \"SignatureDoesNotMatch\":\n                logger.critical(\"Invalid secret key provided for the secret backend bucket user.\")\n            if s3e.code == \"InvalidAccessKeyId\":\n                logger.critical(\"Invalid access key ID provided for the secret backend bucket user.\")\n            if s3e.code == \"AccessDenied\":\n                logger.critical(\n                    \"Access denied for the secret backend bucket user. Does the bucket exist, and does the \"\n                    \"user have the correct permissions to the bucket?\"\n                )\n            sys.exit(10)\n        return s3\n\n    def setup_backend(self):\n        \"\"\"We dynamically configure the backend depending on the given backend type.\"\"\"\n        logger.debug(f\"Configuring SecretManager with backend {self.backend_type}\")\n        method_name = f\"retrieve_{self.backend_type}_backend\"\n        method = getattr(self, method_name)\n        return method()\n\n    def get_credentials(self, name: str, required: bool = False) -&gt; ServiceAccount:\n        \"\"\"Get a password from the configured secret backend.\n\n        Args:\n            name (str): the name of the password entry\n            required (bool): whether the credentials must exist\n\n        Returns: MinioCredentials\n        \"\"\"\n        method_name = f\"{self.backend_type}_get_credentials\"\n        method = getattr(self, method_name)\n        return method(name, required)\n\n    def set_password(self, credentials: ServiceAccount):\n        method_name = f\"{self.backend_type}_set_password\"\n        method = getattr(self, method_name)\n        self.backend_dirty = True\n        return method(credentials)\n\n    def retrieve_dummy_backend(self, config):\n        raise NotImplementedError\n\n    def dummy_get_credentials(self, name):\n        raise NotImplementedError\n\n    def dummy_set_password(self, credentials: ServiceAccount):\n        raise NotImplementedError\n\n    def retrieve_keepass_backend(self) -&gt; PyKeePass:\n        \"\"\"Back-end implementation for the keepass backend.\n        Two-step process:\n            - first we retrieve the kdbx file from the S3 bucket\n            - then we configure the PyKeePass backend\n\n        Returns: PyKeePass object, with the kdbx file loaded\n\n        \"\"\"\n        self.backend_filename = get_env_var(\"MINIO_MANAGER_KEEPASS_FILE\", \"secrets.kdbx\")\n        tmp_file = NamedTemporaryFile(suffix=self.backend_filename, delete=False)\n        self.keepass_temp_file_name = tmp_file.name\n        try:\n            response = self.backend_s3.get_object(self.backend_bucket, self.backend_filename)\n            with tmp_file as f:\n                logger.debug(f\"Writing kdbx file to temp file {tmp_file.name}\")\n                f.write(response.data)\n        except S3Error as s3e:\n            logger.debug(s3e)\n            logger.critical(\n                f\"Unable to retrieve {self.backend_filename} from {self.backend_bucket}!\\n\"\n                \"Do the required bucket and kdbx file exist, and does the user have the correct \"\n                \"policies assigned?\"\n            )\n            sys.exit(11)\n        finally:\n            response.close()\n            response.release_conn()\n\n        kp_pass = get_env_var(\"MINIO_MANAGER_KEEPASS_PASSWORD\")\n        logger.debug(\"Opening keepass database\")\n        try:\n            kp = PyKeePass(self.keepass_temp_file_name, password=kp_pass)\n        except CredentialsError:\n            logger.critical(\"Invalid credentials for Keepass database.\")\n            sys.exit(13)\n        # noinspection PyTypeChecker\n        self.keepass_group = kp.find_groups(path=[\"s3\", self._cluster_name])\n        if not self.keepass_group:\n            logger.critical(\"Required group not found in Keepass! See documentation for requirements.\")\n            sys.exit(12)\n        logger.debug(\"Keepass configured as secret backend\")\n        return kp\n\n    def keepass_get_credentials(self, name: str, required: bool) -&gt; ServiceAccount:\n        \"\"\"Get a password from the configured Keepass database.\n\n        Args:\n            name (str): the name of the password entry\n            required (bool): if the entry must exist\n\n        Returns:\n            ServiceAccount\n        \"\"\"\n        logger.debug(f\"Finding Keepass entry for {name}\")\n        entry = self.backend.find_entries(title=name, group=self.keepass_group, first=True)\n\n        try:\n            credentials = ServiceAccount(name=name, access_key=entry.username, secret_key=entry.password)\n            logger.debug(f\"Found access key {credentials.access_key}\")\n        except AttributeError as ae:\n            if not ae.obj:\n                if required:\n                    logger.critical(f\"Required entry for {name} not found!\")\n                    sys.exit(14)\n                return ServiceAccount(name=name)\n            logger.critical(f\"Unhandled exception: {ae}\")\n        else:\n            return credentials\n\n    def keepass_set_password(self, credentials: ServiceAccount):\n        \"\"\"Set the password for the given credentials.\n\n        Args:\n            credentials (ServiceAccount): the credentials to set\n        \"\"\"\n        logger.info(f\"Creating Keepass entry for {credentials.access_key}\")\n        self.backend.add_entry(\n            destination_group=self.keepass_group,\n            title=credentials.name,\n            username=credentials.access_key,\n            password=credentials.secret_key,\n        )\n\n    def cleanup(self):\n        if not self.backend_dirty:\n            if self.keepass_temp_file_name:\n                Path(self.keepass_temp_file_name).unlink()\n            return\n\n        # If we have dirty back-ends, we want to ensure they are saved before exiting.\n        if self.backend_type == \"keepass\":\n            # The PyKeePass save() function can take some time. So we want to run it once when the application is\n            # exiting, not every time after creating or updating an entry.\n            # After saving, upload the updated file to the S3 bucket and clean up the temp file.\n            tmp_file = Path(self.keepass_temp_file_name)\n            if isinstance(self.backend, PyKeePass):\n                logger.info(f\"Saving {self.keepass_temp_file_name}\")\n                self.backend.save()\n                logger.info(f\"Uploading modified {self.keepass_temp_file_name} to bucket {self.backend_bucket}\")\n                self.backend_s3.fput_object(self.backend_bucket, self.backend_filename, tmp_file)\n            logger.debug(f\"Cleaning up {tmp_file}\")\n            tmp_file.unlink()\n</code></pre>"},{"location":"modules/#minio_manager.classes.config.ClusterResources.parse_bucket_lifecycle_file","title":"<code>parse_bucket_lifecycle_file(lifecycle_file)</code>","text":"<p>Parse a bucket lifecycle config file. The config files must be in JSON format and can be best obtained by running the following command:     mc ilm rule export \\(cluster/\\)bucket &gt; $policy_file.json</p> <p>Parameters:</p> Name Type Description Default <code>lifecycle_file</code> <code>str</code> <p>lifecycle config file</p> required <p>Returns:</p> Type Description <code>LifecycleConfig | None</code> <p>LifecycleConfig object</p> Source code in <code>minio_manager/classes/config.py</code> <pre><code>def parse_bucket_lifecycle_file(self, lifecycle_file: str) -&gt; LifecycleConfig | None:\n    \"\"\"Parse a bucket lifecycle config file.\n    The config files must be in JSON format and can be best obtained by running the following command:\n        mc ilm rule export $cluster/$bucket &gt; $policy_file.json\n\n    Args:\n        lifecycle_file: lifecycle config file\n\n    Returns:\n        LifecycleConfig object\n    \"\"\"\n    if not lifecycle_file:\n        return\n\n    rules: list = []\n\n    try:\n        with Path(lifecycle_file).open() as f:\n            config_data = json.load(f)\n    except FileNotFoundError:\n        logger.error(f\"Lifecycle file {lifecycle_file} not found, skipping configuration.\")\n        sys.exit(1)\n    except PermissionError:\n        logger.error(f\"Incorrect file permissions on {lifecycle_file}, skipping configuration.\")\n        sys.exit(1)\n\n    try:\n        rules_dict = config_data[\"Rules\"]\n    except KeyError:\n        logger.error(f\"Lifecycle file {lifecycle_file} is missing the required 'Rules' key.\")\n        sys.exit(1)\n    try:\n        for rule_data in rules_dict:\n            parsed_rule = self.parse_bucket_lifecycle_rule(rule_data)\n            rules.append(parsed_rule)\n    except AttributeError:\n        logger.error(f\"Error parsing lifecycle file {lifecycle_file}. Is the format correct?\")\n        sys.exit(1)\n\n    if not rules:\n        return\n\n    return LifecycleConfig(rules)\n</code></pre>"},{"location":"modules/#minio_manager.classes.config.ClusterResources.parse_bucket_lifecycle_rule","title":"<code>parse_bucket_lifecycle_rule(rule_data)</code>  <code>staticmethod</code>","text":"<p>Parse a single bucket object lifecycle rule TODO: implement date and days in Expiration, implement Transition, NoncurrentVersionTransition, Filter, and   AbortIncompleteMultipartUpload</p> <p>Parameters:</p> Name Type Description Default <code>rule_data</code> <code>dict</code> <p>dict with rule data</p> required <p>Returns:</p> Type Description <code>Rule</code> <p>Rule</p> Source code in <code>minio_manager/classes/config.py</code> <pre><code>@staticmethod\ndef parse_bucket_lifecycle_rule(rule_data: dict) -&gt; Rule:\n    \"\"\"Parse a single bucket object lifecycle rule\n    TODO: implement date and days in Expiration, implement Transition, NoncurrentVersionTransition, Filter, and\n      AbortIncompleteMultipartUpload\n\n    Args:\n        rule_data: dict with rule data\n\n    Returns:\n        Rule\n    \"\"\"\n    rule_dict = {\"status\": rule_data.get(\"Status\"), \"rule_id\": rule_data.get(\"ID\")}\n\n    expiration = rule_data.get(\"Expiration\")\n    if expiration:\n        expire_delete_marker = expiration.get(\"ExpiredObjectDeleteMarker\")\n        rule_dict[\"expiration\"] = Expiration(expired_object_delete_marker=expire_delete_marker)\n\n    noncurrent_version_expiration = rule_data.get(\"NoncurrentVersionExpiration\")\n    if noncurrent_version_expiration:\n        noncurrent_expire_days = noncurrent_version_expiration.get(\"NoncurrentDays\")\n        rule_dict[\"noncurrent_version_expiration\"] = NoncurrentVersionExpiration(noncurrent_expire_days)\n\n    # An empty filter is required for the rule to be valid\n    rule_dict[\"rule_filter\"] = Filter(prefix=\"\")\n\n    rule = Rule(**rule_dict)\n    return rule\n</code></pre>"},{"location":"modules/#minio_manager.classes.config.ClusterResources.parse_buckets","title":"<code>parse_buckets(buckets)</code>","text":"<p>Parse the provided buckets with the following steps: For each provided bucket     1. check the provided versioning. If versioning is not provided, set the default.     2. check if an object lifecycle JSON file is provided, use the default_bucket_lifecycle_policy, or skip OLM     3. parse the file and create a LifecycleConfig object for the bucket     4. create a Bucket object</p> <p>Parameters:</p> Name Type Description Default <code>buckets</code> <code>list[dict]</code> <p>list of buckets to parse</p> required <p>Returns:</p> Type Description <code>list[Bucket]</code> <p>[Bucket]: list of Bucket objects</p> Source code in <code>minio_manager/classes/config.py</code> <pre><code>def parse_buckets(self, buckets: list[dict]) -&gt; list[Bucket]:\n    \"\"\"Parse the provided buckets with the following steps:\n    For each provided bucket\n        1. check the provided versioning. If versioning is not provided, set the default.\n        2. check if an object lifecycle JSON file is provided, use the default_bucket_lifecycle_policy, or skip OLM\n        3. parse the file and create a LifecycleConfig object for the bucket\n        4. create a Bucket object\n\n    Args:\n        buckets: list of buckets to parse\n\n    Returns:\n        [Bucket]: list of Bucket objects\n    \"\"\"\n    if not buckets:\n        logger.info(\"No buckets configured, skipping.\")\n        return []\n\n    bucket_objects = []\n    if not isinstance(buckets, list):\n        logger.error(\"buckets must be defined as a list!\")\n        sys.exit(1)\n\n    lifecycle_config = self.parse_bucket_lifecycle_file(default_bucket_lifecycle_policy)\n    bucket_names = []\n\n    for bucket in buckets:\n        name = bucket[\"name\"]\n        if name in bucket_names:\n            logger.error(f\"Bucket '{name}' defined multiple times. Stopping.\")\n            sys.exit(1)\n        bucket_names.append(name)\n        logger.debug(f\"Parsing bucket {name}\")\n        if not name.startswith(default_bucket_allowed_prefix):\n            logger.error(f\"Bucket {name} does not start with required prefix '{default_bucket_allowed_prefix}'.\")\n            sys.exit(1)\n\n        versioning = bucket.get(\"versioning\")\n        try:\n            versioning_config = VeCo(versioning) if versioning else VeCo(default_bucket_versioning)\n        except ValueError as ve:\n            logger.error(f\"Error parsing versioning setting: {' '.join(ve.args)}\")\n            sys.exit(1)\n        create_sa = bool(bucket.get(\"create_service_account\", default_bucket_create_service_account))\n        lifecycle_file = bucket.get(\"object_lifecycle_file\")\n        if lifecycle_file:\n            bucket_lifecycle = self.parse_bucket_lifecycle_file(lifecycle_file)\n            if isinstance(bucket_lifecycle, LifecycleConfig):\n                lifecycle_config = bucket_lifecycle\n        bucket_objects.append(Bucket(name, create_sa, versioning_config, lifecycle_config))\n\n    return bucket_objects\n</code></pre>"},{"location":"modules/#minio_manager.classes.mc_wrapper.McWrapper.configure","title":"<code>configure(endpoint, access_key, secret_key, secure)</code>","text":"<p>Ensure the proper alias is configured for the cluster.</p> Source code in <code>minio_manager/classes/mc_wrapper.py</code> <pre><code>def configure(self, endpoint, access_key, secret_key, secure: bool):\n    \"\"\"Ensure the proper alias is configured for the cluster.\"\"\"\n    logger.debug(f\"Validating config for cluster {self.cluster_name}\")\n    cluster_ready = self._run([\"ready\", self.cluster_name])\n    logger.debug(f\"Cluster status: {cluster_ready}\")\n    error = cluster_ready.get(\"error\")\n    if not error:\n        # Cluster is configured &amp; available\n        return\n\n    logger.info(\"Endpoint is not configured or erroneous, configuring...\")\n    url = f\"https://{endpoint}\" if secure else f\"http://{endpoint}\"\n    alias_set_resp = self._run([\"alias\", \"set\", self.cluster_name, url, access_key, secret_key])\n    if alias_set_resp.get(\"error\"):\n        error_details = alias_set_resp[\"error\"][\"cause\"][\"error\"]\n        try:\n            raise_specific_error(error_details[\"Code\"], error_details[\"Message\"])\n        except AttributeError as ae:\n            logger.exception(\"Unknown error!\")\n            raise MinioManagerBaseError(alias_set_resp[\"error\"][\"cause\"][\"message\"]) from ae\n\n    cluster_ready = self._run([\"ready\", self.cluster_name])\n    healthy = cluster_ready.get(\"healthy\")\n    if healthy:\n        # Cluster is configured &amp; available\n        return\n\n    if cluster_ready.get(\"error\"):\n        # A connection error occurred\n        raise ConnectionError(cluster_ready[\"error\"])\n</code></pre>"},{"location":"modules/#minio_manager.classes.mc_wrapper.McWrapper.find_mc_command","title":"<code>find_mc_command()</code>  <code>staticmethod</code>","text":"<p>Configure the path to the mc command, as it may be named 'mcli' on some systems.</p> Source code in <code>minio_manager/classes/mc_wrapper.py</code> <pre><code>@staticmethod\ndef find_mc_command() -&gt; Path:\n    \"\"\"Configure the path to the mc command, as it may be named 'mcli' on some systems.\"\"\"\n    mc = shutil.which(\"mc\")\n    if not mc:\n        mc = shutil.which(\"mcli\")\n    return Path(mc)\n</code></pre>"},{"location":"modules/#minio_manager.classes.mc_wrapper.McWrapper.service_account_add","title":"<code>service_account_add(credentials)</code>","text":"<p>mc admin user svcacct add alias-name 'username' --name \"sa-test-key\"</p> <p>Parameters:</p> Name Type Description Default <code>credentials</code> <code>ServiceAccount</code> <p>object containing at least the user-friendly name of the service account</p> required <p>Returns: ServiceAccount with the access and secret keys added to it</p> Source code in <code>minio_manager/classes/mc_wrapper.py</code> <pre><code>def service_account_add(self, credentials: ServiceAccount) -&gt; ServiceAccount:\n    \"\"\"\n    mc admin user svcacct add alias-name 'username' --name \"sa-test-key\"\n\n    Args:\n        credentials (ServiceAccount): object containing at least the user-friendly name of the service account\n\n    Returns: ServiceAccount with the access and secret keys added to it\n    \"\"\"\n    # Create the service account in MinIO\n    args = [self.cluster_controller_user, \"--name\", credentials.name]\n    if credentials.description:\n        args.extend([\"--description\", credentials.description])\n    if credentials.secret_key:\n        args.extend([\"--secret-key\", credentials.secret_key])\n    if credentials.access_key:\n        args.extend([\"--access-key\", credentials.access_key])\n    resp = self._service_account_run(\"add\", args)\n    credentials.access_key = resp[\"accessKey\"]\n    credentials.secret_key = resp[\"secretKey\"]\n    return credentials\n</code></pre>"},{"location":"modules/#minio_manager.classes.mc_wrapper.McWrapper.service_account_delete","title":"<code>service_account_delete()</code>","text":"<p>mc admin user svcacct rm alias-name service-account-access-key</p> Source code in <code>minio_manager/classes/mc_wrapper.py</code> <pre><code>def service_account_delete(self):\n    \"\"\"mc admin user svcacct rm alias-name service-account-access-key\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/#minio_manager.classes.mc_wrapper.McWrapper.service_account_info","title":"<code>service_account_info(access_key)</code>","text":"<p>mc admin user svcacct info alias-name service-account-access-key</p> Source code in <code>minio_manager/classes/mc_wrapper.py</code> <pre><code>def service_account_info(self, access_key) -&gt; dict:\n    \"\"\"mc admin user svcacct info alias-name service-account-access-key\"\"\"\n    return self._service_account_run(\"info\", [access_key])\n</code></pre>"},{"location":"modules/#minio_manager.classes.mc_wrapper.McWrapper.service_account_list","title":"<code>service_account_list(access_key)</code>","text":"<p>mc admin user svcacct ls alias-name 'access_key'</p> Source code in <code>minio_manager/classes/mc_wrapper.py</code> <pre><code>def service_account_list(self, access_key) -&gt; list[dict]:\n    \"\"\"mc admin user svcacct ls alias-name 'access_key'\"\"\"\n    return self._service_account_run(\"ls\", [access_key])\n</code></pre>"},{"location":"modules/#minio_manager.classes.mc_wrapper.McWrapper.service_account_set_policy","title":"<code>service_account_set_policy(access_key, policy_file)</code>","text":"<p>mc admin user svcacct edit alias-name service-account-access-key --policy policy-file</p> Source code in <code>minio_manager/classes/mc_wrapper.py</code> <pre><code>def service_account_set_policy(self, access_key: str, policy_file: str):\n    \"\"\"mc admin user svcacct edit alias-name service-account-access-key --policy policy-file\"\"\"\n    return self._service_account_run(\"edit\", [access_key, \"--policy\", policy_file])\n</code></pre>"},{"location":"modules/#minio_manager.classes.mc_wrapper.McWrapper.set_config_path","title":"<code>set_config_path()</code>  <code>staticmethod</code>","text":"<p>Set the path to the mc config.json file</p> Source code in <code>minio_manager/classes/mc_wrapper.py</code> <pre><code>@staticmethod\ndef set_config_path():\n    \"\"\"Set the path to the mc config.json file\"\"\"\n    env_mc_config_path = os.getenv(\"MC_CONFIG_PATH\")\n    env_home = os.getenv(\"HOME\")\n    mc_paths = [\n        f\"{env_mc_config_path}/config.json\",\n        f\"{env_home}/.mc/config.json\",\n        f\"{env_home}/.mcli/config.json\",\n    ]\n    for path in mc_paths:\n        if os.path.exists(path):\n            return path\n</code></pre>"},{"location":"modules/#minio_manager.classes.minio_resources.ServiceAccount.generate_service_account_policy","title":"<code>generate_service_account_policy()</code>","text":"<p>Generate a policy for a service account that gives access to a bucket with the same name as the service account.</p> Source code in <code>minio_manager/classes/minio_resources.py</code> <pre><code>def generate_service_account_policy(self):\n    \"\"\"\n    Generate a policy for a service account that gives access to a bucket with the same name as the service account.\n    \"\"\"\n    with Path(sa_policy_base_file).open() as base:\n        base_policy = base.read()\n\n    temp_file = NamedTemporaryFile(prefix=self.name, suffix=\".json\", delete=False)\n    with temp_file as out:\n        new_content = base_policy.replace(\"BUCKET_NAME_REPLACE_ME\", self.name)\n        out.write(new_content.encode(\"utf-8\"))\n\n    self.policy = json.loads(new_content)\n    self.policy_file = Path(temp_file.name)\n</code></pre>"},{"location":"modules/#minio_manager.classes.secrets.SecretManager.get_credentials","title":"<code>get_credentials(name, required=False)</code>","text":"<p>Get a password from the configured secret backend.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the password entry</p> required <code>required</code> <code>bool</code> <p>whether the credentials must exist</p> <code>False</code> <p>Returns: MinioCredentials</p> Source code in <code>minio_manager/classes/secrets.py</code> <pre><code>def get_credentials(self, name: str, required: bool = False) -&gt; ServiceAccount:\n    \"\"\"Get a password from the configured secret backend.\n\n    Args:\n        name (str): the name of the password entry\n        required (bool): whether the credentials must exist\n\n    Returns: MinioCredentials\n    \"\"\"\n    method_name = f\"{self.backend_type}_get_credentials\"\n    method = getattr(self, method_name)\n    return method(name, required)\n</code></pre>"},{"location":"modules/#minio_manager.classes.secrets.SecretManager.keepass_get_credentials","title":"<code>keepass_get_credentials(name, required)</code>","text":"<p>Get a password from the configured Keepass database.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the password entry</p> required <code>required</code> <code>bool</code> <p>if the entry must exist</p> required <p>Returns:</p> Type Description <code>ServiceAccount</code> <p>ServiceAccount</p> Source code in <code>minio_manager/classes/secrets.py</code> <pre><code>def keepass_get_credentials(self, name: str, required: bool) -&gt; ServiceAccount:\n    \"\"\"Get a password from the configured Keepass database.\n\n    Args:\n        name (str): the name of the password entry\n        required (bool): if the entry must exist\n\n    Returns:\n        ServiceAccount\n    \"\"\"\n    logger.debug(f\"Finding Keepass entry for {name}\")\n    entry = self.backend.find_entries(title=name, group=self.keepass_group, first=True)\n\n    try:\n        credentials = ServiceAccount(name=name, access_key=entry.username, secret_key=entry.password)\n        logger.debug(f\"Found access key {credentials.access_key}\")\n    except AttributeError as ae:\n        if not ae.obj:\n            if required:\n                logger.critical(f\"Required entry for {name} not found!\")\n                sys.exit(14)\n            return ServiceAccount(name=name)\n        logger.critical(f\"Unhandled exception: {ae}\")\n    else:\n        return credentials\n</code></pre>"},{"location":"modules/#minio_manager.classes.secrets.SecretManager.keepass_set_password","title":"<code>keepass_set_password(credentials)</code>","text":"<p>Set the password for the given credentials.</p> <p>Parameters:</p> Name Type Description Default <code>credentials</code> <code>ServiceAccount</code> <p>the credentials to set</p> required Source code in <code>minio_manager/classes/secrets.py</code> <pre><code>def keepass_set_password(self, credentials: ServiceAccount):\n    \"\"\"Set the password for the given credentials.\n\n    Args:\n        credentials (ServiceAccount): the credentials to set\n    \"\"\"\n    logger.info(f\"Creating Keepass entry for {credentials.access_key}\")\n    self.backend.add_entry(\n        destination_group=self.keepass_group,\n        title=credentials.name,\n        username=credentials.access_key,\n        password=credentials.secret_key,\n    )\n</code></pre>"},{"location":"modules/#minio_manager.classes.secrets.SecretManager.retrieve_keepass_backend","title":"<code>retrieve_keepass_backend()</code>","text":"<p>Back-end implementation for the keepass backend. Two-step process:     - first we retrieve the kdbx file from the S3 bucket     - then we configure the PyKeePass backend</p> <p>Returns: PyKeePass object, with the kdbx file loaded</p> Source code in <code>minio_manager/classes/secrets.py</code> <pre><code>def retrieve_keepass_backend(self) -&gt; PyKeePass:\n    \"\"\"Back-end implementation for the keepass backend.\n    Two-step process:\n        - first we retrieve the kdbx file from the S3 bucket\n        - then we configure the PyKeePass backend\n\n    Returns: PyKeePass object, with the kdbx file loaded\n\n    \"\"\"\n    self.backend_filename = get_env_var(\"MINIO_MANAGER_KEEPASS_FILE\", \"secrets.kdbx\")\n    tmp_file = NamedTemporaryFile(suffix=self.backend_filename, delete=False)\n    self.keepass_temp_file_name = tmp_file.name\n    try:\n        response = self.backend_s3.get_object(self.backend_bucket, self.backend_filename)\n        with tmp_file as f:\n            logger.debug(f\"Writing kdbx file to temp file {tmp_file.name}\")\n            f.write(response.data)\n    except S3Error as s3e:\n        logger.debug(s3e)\n        logger.critical(\n            f\"Unable to retrieve {self.backend_filename} from {self.backend_bucket}!\\n\"\n            \"Do the required bucket and kdbx file exist, and does the user have the correct \"\n            \"policies assigned?\"\n        )\n        sys.exit(11)\n    finally:\n        response.close()\n        response.release_conn()\n\n    kp_pass = get_env_var(\"MINIO_MANAGER_KEEPASS_PASSWORD\")\n    logger.debug(\"Opening keepass database\")\n    try:\n        kp = PyKeePass(self.keepass_temp_file_name, password=kp_pass)\n    except CredentialsError:\n        logger.critical(\"Invalid credentials for Keepass database.\")\n        sys.exit(13)\n    # noinspection PyTypeChecker\n    self.keepass_group = kp.find_groups(path=[\"s3\", self._cluster_name])\n    if not self.keepass_group:\n        logger.critical(\"Required group not found in Keepass! See documentation for requirements.\")\n        sys.exit(12)\n    logger.debug(\"Keepass configured as secret backend\")\n    return kp\n</code></pre>"},{"location":"modules/#minio_manager.classes.secrets.SecretManager.setup_backend","title":"<code>setup_backend()</code>","text":"<p>We dynamically configure the backend depending on the given backend type.</p> Source code in <code>minio_manager/classes/secrets.py</code> <pre><code>def setup_backend(self):\n    \"\"\"We dynamically configure the backend depending on the given backend type.\"\"\"\n    logger.debug(f\"Configuring SecretManager with backend {self.backend_type}\")\n    method_name = f\"retrieve_{self.backend_type}_backend\"\n    method = getattr(self, method_name)\n    return method()\n</code></pre>"}]}