{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"minio-manager","text":"<p>Declare what MinIO buckets, IAM policies, ILM policies you want, and let MinIO Manager do the work.</p> <ul> <li>GitHub repository: https://github.com/alveel/minio-manager/</li> <li>Documentation https://alveel.github.io/minio-manager/</li> </ul>"},{"location":"#description","title":"Description","text":"<p>The concept for management is to have so-called \"bucket groups\".</p> <p>Each bucket group is managed by an account that only has access to buckets in that group.</p> <p>It should be noted that this is explicitly intended for the creation and updating of resources in MinIO. It does not delete any resources anywhere.</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python (3.9 or newer)</li> <li>PDM</li> <li>MinIO Client</li> </ul>"},{"location":"#getting-started-with-your-project","title":"Getting started with your project","text":"<p>Install the environment and the pre-commit hooks with</p> <pre><code>make install\n</code></pre> <p>You are now ready to start development on your project! The CI/CD pipeline will be triggered when you open a pull request, merge to main, or when you create a new release.</p> <p>To finalize the set-up for publishing to PyPi or Artifactory, see here. For activating the automatic documentation with MkDocs, see here. To enable the code coverage reports, see here.</p>"},{"location":"#to-do-features","title":"To do features","text":"<p>Check the open enhancement issues.</p> <p>Repository initiated with fpgmaas/cookiecutter-pdm.</p>"},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#environment-variables","title":"Environment variables","text":"<p>Required variables without a default value must be manually configured.</p> Variable Description Required Default <code>MINIO_MANAGER_CLUSTER_NAME</code> The name of the cluster, used to query the secret backend Yes <code>MINIO_MANAGER_S3_ENDPOINT</code>\u00b9 What host:port to use as MinIO/S3 endpoint Yes <code>MINIO_MANAGER_S3_ENDPOINT_SECURE</code> Whether to use HTTPS for the endpoint Yes <code>True</code> <code>MINIO_MANAGER_MINIO_CONTROLLER_USER</code> The name of the entry in the secret backend for the controller user Yes <code>MINIO_MANAGER_SECRET_BACKEND_TYPE</code>\u00b2 What secret backend to use Yes <code>MINIO_MANAGER_SECRET_BACKEND_S3_BUCKET</code> The name of the bucket where the secret backend is kept Yes <code>minio-manager-secrets</code> <code>MINIO_MANAGER_SECRET_BACKEND_S3_ACCESS_KEY</code> The access key to the S3 bucket where the secret database is stored Yes <code>MINIO_MANAGER_SECRET_BACKEND_S3_SECRET_KEY</code> The secret key to the S3 bucket where the secret database is stored Yes <code>MINIO_MANAGER_KEEPASS_PASSWORD</code> Keepass database password With Keepass <code>MINIO_MANAGER_KEEPASS_FILENAME</code> he name of the database file in the S3 bucket Yes <code>secrets.kdbx</code> <code>MINIO_MANAGER_CLUSTER_RESOURCES_FILE</code> The YAML file with the MinIO resource configuration (buckets, policies, etc.) Yes <code>resources.yaml</code> <code>MINIO_MANAGER_LOG_LEVEL</code>\u00b3 The log level of the application. No <code>INFO</code> <code>MINIO_MANAGER_DEFAULT_BUCKET_VERSIONING</code> Whether to globally enable (<code>Enabled</code>) or suspend (<code>Suspended</code>) bucket versioning Yes <code>Suspended</code> <code>MINIO_MANAGER_DEFAULT_LIFECYCLE_POLICY_FILE</code> What lifecycle policy (in <code>mc ilm export</code> format) to attach to all buckets by default No <code>MINIO_MANAGER_AUTO_CREATE_SERVICE_ACCOUNT</code> Whether to automatically create service accounts with a generated access policy No <code>True</code> <code>MINIO_MANAGER_SERVICE_ACCOUNT_POLICY_BASE_FILE</code>\u2074 What policy to use as a base for a service account when automatically generated No <code>service-account-policy-base.json</code> <code>MINIO_MANAGER_ALLOWED_BUCKET_PREFIXES</code> Comma-separated list of prefixes of bucket names this controller user is allowed to manage No <code>\"\"</code> <ol> <li>Only specify the host and port as per the example <code>.env</code>, without <code>https://</code> or trailing slashes</li> <li>Currently only Keepass is supported</li> <li>Possible values are <code>INFO</code> or <code>DEBUG</code></li> <li>Defaults to <code>service-account-policy-base.json</code>. MUST contain <code>BUCKET_NAME_REPLACE_ME</code> in the resources to work</li> </ol>"},{"location":"configuration/#examples","title":"Examples","text":""},{"location":"configuration/#configenv","title":"<code>config.env</code>","text":"<pre><code># Required\nexport MINIO_MANAGER_CLUSTER_NAME=local-test\nexport MINIO_MANAGER_S3_ENDPOINT=127.0.0.1:9000\nexport MINIO_MANAGER_MINIO_CONTROLLER_USER=minioadmin\nexport MINIO_MANAGER_SECRET_BACKEND_TYPE=keepass\nexport MINIO_MANAGER_SECRET_BACKEND_S3_ACCESS_KEY=minioadmin\nexport MINIO_MANAGER_SECRET_BACKEND_S3_SECRET_KEY=\"minioadmin\"\n\n# Required for Keepass\nexport MINIO_MANAGER_KEEPASS_PASSWORD=\"very-secure-much-wow\"\n\n# Optional\nexport MINIO_MANAGER_CLUSTER_RESOURCES_FILE=resources.yaml\nexport MINIO_MANAGER_S3_ENDPOINT_SECURE=False\nexport MINIO_MANAGER_SECRET_BACKEND_S3_BUCKET=minio-manager-secrets\nexport MINIO_MANAGER_KEEPASS_FILE=secrets.kdbx\nexport MINIO_MANAGER_LOG_LEVEL=INFO\nexport MINIO_MANAGER_DEFAULT_BUCKET_VERSIONING=Enabled\nexport MINIO_MANAGER_DEFAULT_LIFECYCLE_POLICY=lifecycle_policies/my_lifecycle.json\nexport MINIO_MANAGER_AUTO_CREATE_SERVICE_ACCOUNT=True\nexport MINIO_MANAGER_SERVICE_ACCOUNT_POLICY_BASE_FILE=my_service_account_policy.json\nexport MINIO_MANAGER_ALLOWED_BUCKET_PREFIXES=infra-test-,infra-dev-\n</code></pre> <p>Source</p>"},{"location":"configuration/#resourcesyaml","title":"<code>resources.yaml</code>","text":"<pre><code>---\n\nbuckets:\n  - name: my-test-bucket\n    create_service_account: True\n    object_lifecycle_file: lifecycle_policies/my_lifecycle.json\n    versioning: Enabled\n  - name: second-test-bucket\n    create_service_account: False\n\nservice_accounts:\n  - name: sa-for-second-test-bucket\n    policy_file: user_policies/my_user.json\n</code></pre> <p>Source</p>"},{"location":"configuration/#service-account-policy-base-file","title":"Service account policy base file","text":"<pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"s3:ListBucket\",\n                \"s3:*Object\",\n                \"s3:*ObjectTagging\",\n                \"s3:GetObjectVersion\",\n                \"s3:*ObjectVersionTagging\",\n                \"s3:*BucketNotification\"\n            ],\n            \"Resource\": [\n                \"arn:aws:s3:::BUCKET_NAME_REPLACE_ME\",\n                \"arn:aws:s3:::BUCKET_NAME_REPLACE_ME/*\"\n            ]\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"s3:ListBucket\",\n                \"s3:*Object\"\n            ],\n            \"Resource\": [\n                \"arn:aws:s3:::access-always-needed\",\n                \"arn:aws:s3:::access-always-needed/*\"\n            ]\n        }\n    ]\n}\n</code></pre> <p>Source</p>"},{"location":"modules/","title":"Modules","text":"<p>ClusterResources is the object containing all the cluster resources:</p> <ul> <li>buckets</li> <li>bucket_policies</li> <li>service_accounts</li> <li>iam_policies</li> <li>iam_policy_attachments</li> </ul> Source code in <code>minio_manager/classes/resource_parser.py</code> <pre><code>class ClusterResources:\n    \"\"\"\n    ClusterResources is the object containing all the cluster resources:\n\n    - buckets\n    - bucket_policies\n    - service_accounts\n    - iam_policies\n    - iam_policy_attachments\n    \"\"\"\n\n    buckets: list[Bucket]\n    bucket_policies: list[BucketPolicy]\n    service_accounts: list[ServiceAccount]\n    iam_policies: list[IamPolicy]\n    iam_policy_attachments: list[IamPolicyAttachment]\n\n    def parse_buckets(self, buckets: list) -&gt; list[Bucket]:\n        \"\"\"\n        Parse the provided buckets with the following steps:\n\n        For each provided bucket\n\n            1. check the provided versioning. If versioning is not provided, set the default.\n            2. check if an object lifecycle JSON file is provided, use the default_bucket_lifecycle_policy, or skip OLM\n            3. parse the file and create a LifecycleConfig object for the bucket\n            4. create a Bucket object\n\n        Args:\n            buckets: list of buckets to parse\n\n        Returns: [Bucket]: list of Bucket objects\n        \"\"\"\n        if not buckets:\n            logger.debug(\"No buckets configured, skipping.\")\n            return []\n\n        bucket_objects = []\n\n        lifecycle_config = self.parse_bucket_lifecycle_file(settings.default_lifecycle_policy_file)\n        bucket_names = []\n\n        try:\n            logger.debug(f\"Parsing {len(buckets)} buckets...\")\n            if settings.allowed_bucket_prefixes:\n                logger.info(f\"Only allowing buckets with the following prefixes: {settings.allowed_bucket_prefixes}\")\n            for bucket in buckets:\n                name = bucket[\"name\"]\n                if name in bucket_names:\n                    logger.error(f\"Bucket '{name}' defined multiple times. Stopping.\")\n                    sys.exit(1)\n                logger.debug(f\"Parsing bucket {name}\")\n                allowed_prefixes = settings.allowed_bucket_prefixes\n                if allowed_prefixes and not name.startswith(allowed_prefixes):\n                    logger.error(\n                        f\"Bucket '{name}' does not start with one of the required prefixes {allowed_prefixes}!\"\n                    )\n                    sys.exit(1)\n\n                bucket_names.append(name)\n                versioning = bucket.get(\"versioning\")\n                try:\n                    versioning_config = VeCo(versioning) if versioning else VeCo(settings.default_bucket_versioning)\n                except ValueError as ve:\n                    logger.error(f\"Error parsing versioning setting: {' '.join(ve.args)}\")\n                    sys.exit(1)\n                create_sa = bool(bucket.get(\"create_service_account\", settings.default_bucket_versioning))\n                lifecycle_file = bucket.get(\"object_lifecycle_file\")\n                if lifecycle_file:\n                    bucket_lifecycle = self.parse_bucket_lifecycle_file(lifecycle_file)\n                    if isinstance(bucket_lifecycle, LifecycleConfig):\n                        lifecycle_config = bucket_lifecycle\n                bucket_objects.append(Bucket(name, create_sa, versioning_config, lifecycle_config))\n        except TypeError:\n            logger.error(\"Buckets must be defined as a list of YAML dictionaries!\")\n            sys.exit(1)\n\n        return bucket_objects\n\n    def parse_bucket_lifecycle_file(self, lifecycle_file: str) -&gt; LifecycleConfig | None:\n        \"\"\"\n        Parse a bucket lifecycle config file.\n\n        The config files must be in JSON format and can be best obtained by running the following command:\n            mc ilm rule export $cluster/$bucket &gt; $policy_file.json\n\n        Args:\n            lifecycle_file: lifecycle config file\n\n        Returns: LifecycleConfig object\n        \"\"\"\n        if not lifecycle_file:\n            return\n\n        rules: list = []\n\n        try:\n            with Path(lifecycle_file).open() as f:\n                config_data = json.load(f)\n        except FileNotFoundError:\n            logger.error(f\"Lifecycle file {lifecycle_file} not found, skipping configuration.\")\n            sys.exit(1)\n        except PermissionError:\n            logger.error(f\"Incorrect file permissions on {lifecycle_file}, skipping configuration.\")\n            sys.exit(1)\n\n        try:\n            rules_dict = config_data[\"Rules\"]\n        except KeyError:\n            logger.error(f\"Lifecycle file {lifecycle_file} is missing the required 'Rules' key.\")\n            sys.exit(1)\n\n        try:\n            for rule_data in rules_dict:\n                parsed_rule = self.parse_bucket_lifecycle_rule(rule_data)\n                rules.append(parsed_rule)\n        except AttributeError:\n            logger.error(f\"Error parsing lifecycle file {lifecycle_file}. Is the format correct?\")\n            sys.exit(1)\n\n        if not rules:\n            return\n\n        return LifecycleConfig(rules)\n\n    @staticmethod\n    def parse_bucket_lifecycle_rule(rule_data: dict) -&gt; Rule:\n        \"\"\"\n        Parse a single bucket object lifecycle rule.\n\n        TODO:\n          Implement date and days in Expiration, implement Transition, NoncurrentVersionTransition, Filter, and\n          AbortIncompleteMultipartUpload\n\n        Args:\n            rule_data: dict with rule data\n\n        Returns: Rule object\n        \"\"\"\n        rule_dict = {\"status\": rule_data.get(\"Status\"), \"rule_id\": rule_data.get(\"ID\")}\n\n        expiration = rule_data.get(\"Expiration\")\n        if expiration:\n            expire_delete_marker = expiration.get(\"ExpiredObjectDeleteMarker\")\n            rule_dict[\"expiration\"] = Expiration(expired_object_delete_marker=expire_delete_marker)\n\n        noncurrent_version_expiration = rule_data.get(\"NoncurrentVersionExpiration\")\n        if noncurrent_version_expiration:\n            noncurrent_expire_days = noncurrent_version_expiration.get(\"NoncurrentDays\")\n            rule_dict[\"noncurrent_version_expiration\"] = NoncurrentVersionExpiration(noncurrent_expire_days)\n\n        # An empty filter is required for the rule to be valid\n        rule_dict[\"rule_filter\"] = Filter(prefix=\"\")\n\n        rule = Rule(**rule_dict)\n        return rule\n\n    @staticmethod\n    def parse_bucket_policies(bucket_policies: list):\n        \"\"\"\n        Parse a list of bucket policy definitions into BucketPolicy objects.\n\n        Args:\n            bucket_policies: list of bucket policies\n\n        Returns: [BucketPolicy]\n        \"\"\"\n        if not bucket_policies:\n            logger.debug(\"No bucket policies configured, skipping.\")\n            return []\n\n        bucket_policy_objects = []\n        try:\n            logger.debug(f\"Parsing {len(bucket_policies)} bucket policies...\")\n            for bucket_policy in bucket_policies:\n                bucket_policy_objects.append(BucketPolicy(bucket_policy[\"bucket\"], bucket_policy[\"policy_file\"]))\n        except TypeError:\n            logger.error(\"Bucket policies must be defined as a list of YAML dictionaries!\")\n            sys.exit(1)\n\n        return bucket_policy_objects\n\n    @staticmethod\n    def parse_service_accounts(service_accounts: list):\n        \"\"\"\n        Parse a list of service account definitions into ServiceAccount objects.\n\n        Args:\n            service_accounts: dict of service accounts\n\n        Returns: [ServiceAccount]\n        \"\"\"\n        if not service_accounts:\n            logger.debug(\"No service accounts configured, skipping.\")\n            return []\n\n        service_account_objects, service_account_names = [], []\n\n        try:\n            logger.debug(f\"Parsing {len(service_accounts)} service accounts...\")\n            for service_account in service_accounts:\n                name = service_account[\"name\"]\n                if name in service_account_names:\n                    logger.error(f\"Service account '{name}' defined multiple times. Stopping.\")\n                    sys.exit(1)\n                service_account_names.append(name)\n                policy_file = service_account.get(\"policy_file\")\n                sa_obj = ServiceAccount(name=name, policy_file=policy_file)\n                service_account_objects.append(sa_obj)\n        except TypeError:\n            logger.error(\"Service accounts must be defined as a list of YAML dictionaries!\")\n            sys.exit(1)\n\n        return service_account_objects\n\n    @staticmethod\n    def parse_iam_attachments(iam_policy_attachments: list):\n        \"\"\"\n        Parse a list of IAM policy attachment definitions into IamPolicyAttachment objects.\n\n        Args:\n            iam_policy_attachments: dict of IAM policy attachments\n\n        Returns: [IamPolicyAttachment]\n        \"\"\"\n        if not iam_policy_attachments:\n            logger.debug(\"No IAM policy attachments configured, skipping.\")\n            return []\n\n        iam_policy_attachment_objects = []\n        try:\n            logger.debug(f\"Parsing {len(iam_policy_attachments)} IAM policy attachments...\")\n            for user in iam_policy_attachments:\n                iam_policy_attachments.append(IamPolicyAttachment(user[\"username\"], user[\"policies\"]))\n        except TypeError:\n            logger.error(\"IAM policy attachments must be defined as a list of YAML dictionaries!\")\n            sys.exit(1)\n\n        return iam_policy_attachment_objects\n\n    @staticmethod\n    def parse_iam_policies(iam_policies: dict):\n        \"\"\"\n        Parse a list of IAM policy definitions into IamPolicy objects.\n\n        Args:\n            iam_policies: dict of IAM policies\n\n        Returns: [IamPolicy]\n        \"\"\"\n        if not iam_policies:\n            logger.debug(\"No IAM policies configured, skipping.\")\n            return []\n\n        iam_policy_objects, iam_policy_names = [], []\n        try:\n            logger.debug(f\"Parsing {len(iam_policies)} IAM policies...\")\n            for iam_policy in iam_policies:\n                name = iam_policy[\"name\"]\n                if name in iam_policy_names:\n                    logger.error(f\"IAM policy '{name}' defined multiple times. Stopping.\")\n                    sys.exit(1)\n                iam_policy_names.append(name)\n                iam_policy_objects.append(IamPolicy(name, iam_policy[\"policy_file\"]))\n        except TypeError:\n            logger.error(\"IAM policies must be defined as a list of YAML dictionaries!\")\n            sys.exit(1)\n\n        return iam_policy_objects\n\n    def parse_resources(self, resources_file: str):\n        \"\"\"\n        Parse resources from a YAML file, ensuring they are valid before trying to use them.\n\n        Args:\n            resources_file: string path to the YAML file\n        \"\"\"\n        logger.info(\"Loading and parsing resources...\")\n\n        try:\n            resources = read_yaml(resources_file)\n        except FileNotFoundError:\n            logger.error(f\"Resources file {resources_file} not found. Stopping.\")\n            sys.exit(1)\n        except PermissionError:\n            logger.error(f\"Incorrect file permissions on {resources_file}. Stopping.\")\n            sys.exit(1)\n\n        if not resources:\n            logger.error(\"Is the resources file empty?\")\n            sys.exit(1)\n\n        buckets = resources.get(\"buckets\")\n        self.buckets = self.parse_buckets(buckets)\n\n        bucket_policies = resources.get(\"bucket_policies\")\n        self.bucket_policies = self.parse_bucket_policies(bucket_policies)\n\n        service_accounts = resources.get(\"service_accounts\")\n        self.service_accounts = self.parse_service_accounts(service_accounts)\n\n        iam_policies = resources.get(\"iam_policies\")\n        self.iam_policies = self.parse_iam_policies(iam_policies)\n\n        iam_policy_attachments = resources.get(\"iam_policy_attachments\")\n        self.iam_policy_attachments = self.parse_iam_attachments(iam_policy_attachments)\n\n        if not any([buckets, bucket_policies, service_accounts, iam_policies, iam_policy_attachments]):\n            logger.warning(\"No resources configured.\")\n            sys.exit(0)\n</code></pre> <p>             Bases: <code>Exception</code></p> <p>Base class for Minio Manager errors.</p> Source code in <code>minio_manager/classes/errors.py</code> <pre><code>class MinioManagerBaseError(Exception):\n    \"\"\"Base class for Minio Manager errors.\"\"\"\n\n    def __init__(self, message: str, cause=None):\n        super().__init__(f\"{message}: {cause}\" if cause else message)\n</code></pre> <p>             Bases: <code>Filter</code></p> <p>The MinioManagerFilter is a custom logging Filter that masks secret values.</p> Source code in <code>minio_manager/classes/logging_config.py</code> <pre><code>class MinioManagerFilter(Filter):\n    \"\"\"\n    The MinioManagerFilter is a custom logging Filter that masks secret values.\n    \"\"\"\n\n    wrapper_secret_re = re.compile(r\"--secret-key (?P&lt;secret&gt;[\\w+/]*)\")\n    alias_set_secret_re = re.compile(r\"alias set .+ (?P&lt;secret&gt;[\\w+/]*)$\")\n    env_keepass_password_re = re.compile(r\"MINIO_MANAGER_KEEPASS_PASSWORD: (?P&lt;secret&gt;[\\w+/]*)$\")\n    env_secret_key_re = re.compile(r\"MINIO_MANAGER_SECRET_BACKEND_S3_SECRET_KEY: (?P&lt;secret&gt;[\\w+/]*)$\")\n\n    def filter(self, record: LogRecord) -&gt; bool:\n        if not isinstance(record.msg, str):\n            return True\n\n        if \"--secret\" in record.msg:\n            record.msg = self.mask_secret(record.msg, self.wrapper_secret_re)\n        if \"alias set\" in record.msg:\n            record.msg = self.mask_secret(record.msg, self.alias_set_secret_re)\n        if \"MINIO_MANAGER_KEEPASS_PASSWORD\" in record.msg:\n            record.msg = self.mask_secret(record.msg, self.env_keepass_password_re)\n        if \"MINIO_MANAGER_SECRET_BACKEND_S3_SECRET_KEY\" in record.msg:\n            record.msg = self.mask_secret(record.msg, self.env_secret_key_re)\n\n        return True\n\n    @staticmethod\n    def mask_secret(message: str, regex: re.Pattern) -&gt; str:\n        result = regex.search(message)\n        if result:\n            message = message.replace(result.group(\"secret\"), \"************\")\n        return message\n</code></pre> <p>             Bases: <code>Formatter</code></p> <p>The MinioManagerFormatter is a custom logging Formatter that provides formatting and colourises log messages.</p> Source code in <code>minio_manager/classes/logging_config.py</code> <pre><code>class MinioManagerFormatter(Formatter):\n    \"\"\"\n    The MinioManagerFormatter is a custom logging Formatter that provides formatting and colourises log messages.\n    \"\"\"\n\n    def __init__(self, level: int):\n        self.log_level = level\n        if level is INFO:\n            log_format = \"[{asctime}] [{levelname:^8s}] {message}\"\n            super().__init__(fmt=log_format, datefmt=\"%Y-%m-%d %H:%M:%S\", style=\"{\")\n        else:\n            log_format = \"[{asctime}] [{levelname:^8s}] [{filename:&gt;26s}:{lineno:&lt;4d} - {funcName:&lt;24s} ] {message}\"\n            super().__init__(fmt=log_format, style=\"{\")\n\n    def format(self, record: LogRecord):\n        if isinstance(record.msg, str) and record.levelname in COLORS:\n            record.msg = COLORS[record.levelname] + record.msg + RESET\n\n        # noinspection StrFormat\n        return super().format(record)\n</code></pre> <p>             Bases: <code>Logger</code></p> <p>The MinioManagerLogger is a custom Logger that implements our MinioManagerFilter and MinioManagerFormatter.</p> Source code in <code>minio_manager/classes/logging_config.py</code> <pre><code>class MinioManagerLogger(Logger):\n    \"\"\"\n    The MinioManagerLogger is a custom Logger that implements our MinioManagerFilter and MinioManagerFormatter.\n    \"\"\"\n\n    def __init__(self, name: str, level: str):\n        super().__init__(name)\n        if level == \"INFO\":\n            self.setLevel(INFO)\n        else:\n            self.setLevel(DEBUG)\n\n        handler = StreamHandler()\n        formatter = MinioManagerFormatter(self.level)\n        this_filter = MinioManagerFilter()\n        handler.setFormatter(formatter)\n        handler.addFilter(this_filter)\n        self.addHandler(handler)\n</code></pre> <p>The McWrapper is responsible for executing mc commands.</p> <p>To be replaced with the new functions in the updated MinioAdmin library.</p> Source code in <code>minio_manager/classes/mc_wrapper.py</code> <pre><code>class McWrapper:\n    \"\"\"\n    The McWrapper is responsible for executing mc commands.\n\n    To be replaced with the new functions in the updated MinioAdmin library.\n    \"\"\"\n\n    def __init__(self, timeout=60):\n        logger.debug(\"Initialising McWrapper\")\n        self.timeout = timeout\n        self.mc_config_path = TemporaryDirectory(prefix=\"mm.mc.\")\n        self.mc = self.find_mc_command()\n        self.configure(\n            endpoint=settings.s3_endpoint,\n            access_key=controller_user.access_key,\n            secret_key=controller_user.secret_key,\n            secure=settings.s3_endpoint_secure,\n        )\n        logger.debug(\"McWrapper initialised\")\n\n    def _run(self, args: list, multiline=False) -&gt; list[dict] | dict:\n        \"\"\"Execute mc command and return JSON output.\"\"\"\n        logger.debug(f\"Running: {self.mc} --config-dir {self.mc_config_path.name} --json {' '.join(args)}\")\n        proc = subprocess.run(\n            [self.mc, \"--config-dir\", self.mc_config_path.name, \"--json\", *args],  # noqa: S603\n            capture_output=True,\n            timeout=self.timeout,\n            text=True,\n        )\n        if not proc.stdout:\n            return [] if multiline else {}\n        if multiline:\n            return [json.loads(line) for line in proc.stdout.splitlines()]\n        return json.loads(proc.stdout)\n\n    @staticmethod\n    def find_mc_command() -&gt; Path:\n        \"\"\"Configure the path to the mc command, as it may be named 'mcli' on some systems.\"\"\"\n        mc = shutil.which(\"mc\")\n        if not mc:\n            mc = shutil.which(\"mcli\")\n        return Path(mc)\n\n    def configure(self, endpoint: str, access_key: str, secret_key: str, secure: bool):\n        \"\"\"Ensure the proper alias is configured for the cluster.\"\"\"\n        logger.info(\"Configuring 'mc'...\")\n        url = f\"https://{endpoint}\" if secure else f\"http://{endpoint}\"\n        alias_set_resp = self._run([\"alias\", \"set\", settings.cluster_name, url, access_key, secret_key])\n        if alias_set_resp.get(\"error\"):\n            error_details = alias_set_resp[\"error\"][\"cause\"][\"error\"]\n            try:\n                raise_specific_error(error_details[\"Code\"], error_details[\"Message\"])\n            except AttributeError as ae:\n                logger.exception(\"Unknown error!\")\n                raise MinioManagerBaseError(alias_set_resp[\"error\"][\"cause\"][\"message\"]) from ae\n\n        cluster_ready = self._run([\"ready\", settings.cluster_name])\n        healthy = cluster_ready.get(\"healthy\")\n        if healthy:\n            # Cluster is configured &amp; available\n            return\n\n        if cluster_ready.get(\"error\"):\n            # A connection error occurred\n            raise ConnectionError(cluster_ready[\"error\"])\n\n    def _service_account_run(self, cmd: str, args: list) -&gt; list[dict] | dict:\n        \"\"\"\n        mc admin user svcacct helper function, no need to specify the cluster name\n        Args:\n            cmd: str, the svcacct command\n            args: list of arguments to the command\n\n        Returns: list | dict\n\n        \"\"\"\n        multiline = cmd in [\"list\", \"ls\"]\n        resp = self._run([\"admin\", \"user\", \"svcacct\", cmd, settings.cluster_name, *args], multiline=multiline)\n        resp_error = resp[0] if multiline else resp\n        if \"error\" in resp_error:\n            resp_error = resp_error[\"error\"]\n            error_details = resp_error[\"cause\"][\"error\"]\n            raise_specific_error(error_details[\"Code\"], error_details[\"Message\"])\n        return resp\n\n    def service_account_add(self, credentials: ServiceAccount) -&gt; ServiceAccount:\n        \"\"\"\n        mc admin user svcacct add alias-name 'username' --name \"sa-test-key\"\n\n        Args:\n            credentials (ServiceAccount): object containing at least the user-friendly name of the service account\n\n        Returns: ServiceAccount with the access and secret keys added to it\n        \"\"\"\n        # Create the service account in MinIO\n        args = [settings.minio_controller_user, \"--name\", credentials.name]\n        if credentials.description:\n            args.extend([\"--description\", credentials.description])\n        if credentials.access_key:\n            args.extend([\"--access-key\", credentials.access_key])\n        if credentials.secret_key:\n            args.extend([\"--secret-key\", credentials.secret_key])\n        resp = self._service_account_run(\"add\", args)\n        credentials.access_key = resp[\"accessKey\"]\n        credentials.secret_key = resp[\"secretKey\"]\n        return credentials\n\n    def service_account_list(self, access_key: str) -&gt; list[dict]:\n        \"\"\"mc admin user svcacct ls alias-name 'access_key'\"\"\"\n        return self._service_account_run(\"ls\", [access_key])\n\n    def service_account_info(self, access_key: str) -&gt; dict:\n        \"\"\"mc admin user svcacct info alias-name service-account-access-key\"\"\"\n        return self._service_account_run(\"info\", [access_key])\n\n    def service_account_delete(self):\n        \"\"\"mc admin user svcacct rm alias-name service-account-access-key\"\"\"\n        raise NotImplementedError\n\n    def service_account_get_policy(self, access_key: str) -&gt; dict:\n        info = self.service_account_info(access_key)\n        return info[\"policy\"]\n\n    def service_account_set_policy(self, access_key: str, policy_file: str):\n        \"\"\"mc admin user svcacct edit alias-name service-account-access-key --policy policy-file\"\"\"\n        return self._service_account_run(\"edit\", [access_key, \"--policy\", policy_file])\n\n    def cleanup(self):\n        \"\"\"\n        We want to clean up the mc config file before the process finishes as otherwise it can cause issues with\n        subsequent runs for different environments.\n        \"\"\"\n        if not self.mc_config_path.name.startswith(\"/tmp\"):  # noqa: S108\n            raise MinioManagerBaseError(\"CleanUpError\", \"Error during cleanup: temporary directory is not in /tmp\")\n        logger.debug(f\"Deleting temporary mc config directory {self.mc_config_path.name}\")\n        self.mc_config_path.cleanup()\n</code></pre> <p>Bucket represents an S3 bucket.</p> <p>name: The name of the bucket create_service_account: Whether to create a service account for the bucket (True or False) versioning: The versioning configuration for the bucket (Enabled or Suspended) lifecycle_config: The path to a lifecycle configuration JSON file for the bucket</p> Source code in <code>minio_manager/classes/minio_resources.py</code> <pre><code>class Bucket:\n    \"\"\"\n    Bucket represents an S3 bucket.\n\n    name: The name of the bucket\n    create_service_account: Whether to create a service account for the bucket (True or False)\n    versioning: The versioning configuration for the bucket (Enabled or Suspended)\n    lifecycle_config: The path to a lifecycle configuration JSON file for the bucket\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        create_service_account: bool = settings.auto_create_service_account,\n        versioning: VersioningConfig | None = None,\n        lifecycle_config: LifecycleConfig | None = None,\n    ):\n        self.name = name\n        self.create_sa = create_service_account\n        self.versioning = versioning\n        self.lifecycle_config = lifecycle_config\n</code></pre> <p>BucketPolicy represents an S3 bucket policy.</p> <p>bucket: The name of the bucket policy_file: The path to a JSON policy file</p> Source code in <code>minio_manager/classes/minio_resources.py</code> <pre><code>class BucketPolicy:\n    \"\"\"\n    BucketPolicy represents an S3 bucket policy.\n\n    bucket: The name of the bucket\n    policy_file: The path to a JSON policy file\n    \"\"\"\n\n    # TODO: try loading the policy file in order to validate its contents\n    def __init__(self, bucket: str, policy_file: str):\n        self.bucket = bucket\n        self.policy_file = policy_file\n</code></pre> <p>ServiceAccount represents a MinIO service account (or S3 access key).</p> <p>name: The name of the service account description: The description of the service account access_key: The access key of the service account secret_key: The secret key of the service account policy: Optional custom policy for the service account policy_file: The path to a JSON policy file</p> Source code in <code>minio_manager/classes/minio_resources.py</code> <pre><code>class ServiceAccount:\n    \"\"\"\n    ServiceAccount represents a MinIO service account (or S3 access key).\n\n    name: The name of the service account\n    description: The description of the service account\n    access_key: The access key of the service account\n    secret_key: The secret key of the service account\n    policy: Optional custom policy for the service account\n    policy_file: The path to a JSON policy file\n    \"\"\"\n\n    policy = ClassVar[dict]\n    policy_file: Path | None\n    policy_generated = False\n\n    def __init__(\n        self,\n        name: str,\n        description: str = \"\",\n        access_key: str | None = None,\n        secret_key: str | None = None,\n        policy: dict | None = None,\n        policy_file: Path | str | None = None,\n    ):\n        if len(name) &gt; 32:\n            self.name = name[:32]\n            self.description = name + \" \" + description\n        else:\n            self.name = name\n            self.description = description\n        self.access_key = access_key\n        self.secret_key = secret_key\n        if policy_file:\n            if isinstance(policy_file, Path):\n                self.policy_file = policy_file\n            else:\n                self.policy_file = Path(policy_file)\n        else:\n            self.policy_file = None\n        if policy:\n            self.policy = policy\n        elif self.policy_file:\n            try:\n                self.policy = read_json(self.policy_file)\n            except FileNotFoundError:\n                logger.critical(f\"Policy file '{self.policy_file}' for service account '{name}' not found!\")\n                sys.exit(1)\n\n    def generate_service_account_policy(self):\n        \"\"\"\n        Generate a policy for a service account that gives access to a bucket with the same name as the service account.\n        \"\"\"\n        if settings.service_account_policy_base_file:\n            with Path(settings.service_account_policy_base_file).open() as base:\n                base_policy = base.read()\n        else:\n            from minio_manager.resources.policies import service_account_policy_base\n\n            base_policy = json.dumps(service_account_policy_base)\n\n        temp_file = NamedTemporaryFile(prefix=self.name, suffix=\".json\", delete=False)\n        with temp_file as out:\n            new_content = base_policy.replace(\"BUCKET_NAME_REPLACE_ME\", self.name)\n            out.write(new_content.encode(\"utf-8\"))\n\n        self.policy = json.loads(new_content)\n        self.policy_file = Path(temp_file.name)\n        self.policy_generated = True\n</code></pre> <p>IamPolicy represents an S3 IAM policy.</p> <p>name: The name of the policy policy_file: The path to a JSON policy file</p> Source code in <code>minio_manager/classes/minio_resources.py</code> <pre><code>class IamPolicy:\n    \"\"\"\n    IamPolicy represents an S3 IAM policy.\n\n    name: The name of the policy\n    policy_file: The path to a JSON policy file\n    \"\"\"\n\n    def __init__(self, name: str, policy_file: str):\n        self.name = name\n        self.policy_file = policy_file\n</code></pre> <p>IamPolicyAttachment represents an S3 IAM policy attachment.</p> <p>username: The name of the user to attach the policies to policies: A list of policies to attach to the user</p> Source code in <code>minio_manager/classes/minio_resources.py</code> <pre><code>class IamPolicyAttachment:\n    \"\"\"\n    IamPolicyAttachment represents an S3 IAM policy attachment.\n\n    username: The name of the user to attach the policies to\n    policies: A list of policies to attach to the user\n    \"\"\"\n\n    def __init__(self, username: str, policies: list):\n        self.username = username\n        self.policies = policies\n</code></pre> <p>SecretManager is responsible for managing credentials</p> Source code in <code>minio_manager/classes/secrets.py</code> <pre><code>class SecretManager:\n    \"\"\"SecretManager is responsible for managing credentials\"\"\"\n\n    def __init__(self):\n        logger.info(\"Loading secret backend...\")\n        self.backend_dirty = False\n        self.backend_type = settings.secret_backend_type\n        self.backend_bucket = settings.secret_backend_s3_bucket\n        self.backend_secure = settings.s3_endpoint_secure\n        self.backend_filename = None\n        self.keepass_temp_file = None\n        self.keepass_group = None\n        self.backend_s3 = self.setup_backend_s3()\n        self.backend = self.setup_backend()\n        logger.debug(f\"Secret backend initialised with {self.backend_type}\")\n\n    def setup_backend_s3(self):\n        endpoint = settings.s3_endpoint\n        access_key = settings.secret_backend_s3_access_key\n        secret_key = settings.secret_backend_s3_secret_key\n        logger.debug(f\"Setting up secret bucket {self.backend_bucket}\")\n        s3 = Minio(endpoint=endpoint, access_key=access_key, secret_key=secret_key, secure=self.backend_secure)\n        try:\n            s3.bucket_exists(self.backend_bucket)\n        except S3Error as s3e:\n            if s3e.code == \"SignatureDoesNotMatch\":\n                logger.critical(\"Invalid secret key provided for the secret backend bucket user.\")\n            if s3e.code == \"InvalidAccessKeyId\":\n                logger.critical(\"Invalid access key ID provided for the secret backend bucket user.\")\n            if s3e.code == \"AccessDenied\":\n                logger.critical(\n                    \"Access denied for the secret backend bucket user. Does the bucket exist, and does the \"\n                    \"user have the correct permissions to the bucket?\"\n                )\n            sys.exit(10)\n        return s3\n\n    def setup_backend(self):\n        \"\"\"We dynamically configure the backend depending on the given backend type.\"\"\"\n        logger.debug(f\"Configuring SecretManager with backend {self.backend_type}\")\n        method_name = f\"retrieve_{self.backend_type}_backend\"\n        method = getattr(self, method_name)\n        return method()\n\n    def get_credentials(self, name: str, required: bool = False) -&gt; ServiceAccount:\n        \"\"\"Get a password from the configured secret backend.\n\n        Args:\n            name (str): the name of the password entry\n            required (bool): whether the credentials must exist\n\n        Returns: MinioCredentials\n        \"\"\"\n        method_name = f\"{self.backend_type}_get_credentials\"\n        method = getattr(self, method_name)\n        return method(name, required)\n\n    def set_password(self, credentials: ServiceAccount):\n        method_name = f\"{self.backend_type}_set_password\"\n        method = getattr(self, method_name)\n        self.backend_dirty = True\n        return method(credentials)\n\n    def retrieve_dummy_backend(self, config):\n        raise NotImplementedError\n\n    def dummy_get_credentials(self, name):\n        raise NotImplementedError\n\n    def dummy_set_password(self, credentials: ServiceAccount):\n        raise NotImplementedError\n\n    def retrieve_keepass_backend(self) -&gt; PyKeePass:\n        \"\"\"Back-end implementation for the keepass backend.\n        Two-step process:\n            - first we retrieve the kdbx file from the S3 bucket\n            - then we configure the PyKeePass backend\n\n        Returns: PyKeePass object, with the kdbx file loaded\n\n        \"\"\"\n        self.backend_filename = settings.keepass_filename\n        tmp_file = NamedTemporaryFile(prefix=f\"mm.{self.backend_filename}.\", delete=False)\n        self.keepass_temp_file = tmp_file\n        try:\n            response = self.backend_s3.get_object(self.backend_bucket, self.backend_filename)\n            with tmp_file as f:\n                logger.debug(f\"Writing kdbx file to temp file {tmp_file.name}\")\n                f.write(response.data)\n        except S3Error as s3e:\n            logger.debug(s3e)\n            logger.critical(\n                f\"Unable to retrieve {self.backend_filename} from {self.backend_bucket}!\\n\"\n                \"Do the required bucket and kdbx file exist, and does the user have the correct \"\n                \"policies assigned?\"\n            )\n            sys.exit(11)\n        finally:\n            response.close()\n            response.release_conn()\n\n        kp_pass = settings.keepass_password\n        logger.debug(\"Opening keepass database\")\n        try:\n            kp = PyKeePass(self.keepass_temp_file.name, password=kp_pass)\n        except CredentialsError:\n            logger.critical(\"Invalid credentials for Keepass database.\")\n            sys.exit(13)\n        # noinspection PyTypeChecker\n        self.keepass_group = kp.find_groups(path=[\"s3\", settings.cluster_name])\n        if not self.keepass_group:\n            logger.critical(\"Required group not found in Keepass! See documentation for requirements.\")\n            sys.exit(12)\n        logger.debug(\"Keepass configured as secret backend\")\n        return kp\n\n    def keepass_get_credentials(self, name: str, required: bool) -&gt; ServiceAccount:\n        \"\"\"Get a password from the configured Keepass database.\n\n        Args:\n            name (str): the name of the password entry\n            required (bool): if the entry must exist\n\n        Returns:\n            ServiceAccount\n        \"\"\"\n        logger.debug(f\"Finding Keepass entry for {name}\")\n        entry = self.backend.find_entries(title=name, group=self.keepass_group, first=True)\n\n        try:\n            credentials = ServiceAccount(name=name, access_key=entry.username, secret_key=entry.password)\n            logger.debug(f\"Found access key {credentials.access_key}\")\n        except AttributeError as ae:\n            if not ae.obj:\n                if required:\n                    logger.critical(f\"Required entry for {name} not found!\")\n                    sys.exit(14)\n                return ServiceAccount(name=name)\n            logger.critical(f\"Unhandled exception: {ae}\")\n        else:\n            return credentials\n\n    def keepass_set_password(self, credentials: ServiceAccount):\n        \"\"\"Set the password for the given credentials.\n\n        Args:\n            credentials (ServiceAccount): the credentials to set\n        \"\"\"\n        logger.debug(f\"Creating Keepass entry '{credentials.name}' with access key '{credentials.access_key}'\")\n        self.backend.add_entry(\n            destination_group=self.keepass_group,\n            title=credentials.name,\n            username=credentials.access_key,\n            password=credentials.secret_key,\n        )\n\n    def cleanup(self):\n        if not self.backend_dirty:\n            if self.keepass_temp_file:\n                self.keepass_temp_file.close()\n                Path(self.keepass_temp_file.name).unlink(missing_ok=True)\n            return\n\n        # If we have dirty back-ends, we want to ensure they are saved before exiting.\n        if self.backend_type == \"keepass\":\n            # The PyKeePass save() function can take some time. So we want to run it once when the application is\n            # exiting, not every time after creating or updating an entry.\n            # After saving, upload the updated file to the S3 bucket and clean up the temp file.\n            if isinstance(self.backend, PyKeePass):\n                t_filename = self.keepass_temp_file.name  # temp file name\n                s_bucket_name = self.backend_bucket  # bucket name\n                s_filename = self.backend_filename  # file name in bucket\n                logger.info(f\"Saving modified {s_filename} and uploading back to bucket {s_bucket_name}.\")\n                logger.debug(f\"Saving temp file {t_filename}\")\n                self.backend.save()\n                logger.debug(f\"Uploading {t_filename} to bucket {s_bucket_name}\")\n                self.backend_s3.fput_object(s_bucket_name, s_filename, t_filename)\n                logger.info(f\"Successfully saved modified {s_filename}.\")\n            logger.debug(f\"Cleaning up {self.keepass_temp_file.name}\")\n            self.keepass_temp_file.close()\n            Path(self.keepass_temp_file.name).unlink(missing_ok=True)\n</code></pre> <p>             Bases: <code>BaseSettings</code></p> <p>The Settings class is responsible for loading the settings from environment variables and the dotenv file, and making them available to the rest of the application.</p> Source code in <code>minio_manager/classes/settings.py</code> <pre><code>class Settings(BaseSettings):\n    \"\"\"\n    The Settings class is responsible for loading the settings from environment variables and the dotenv file, and\n    making them available to the rest of the application.\n    \"\"\"\n\n    model_config = SettingsConfigDict(\n        env_prefix=\"MINIO_MANAGER_\", env_file=\"config.env\", env_file_encoding=\"utf-8\", extra=\"ignore\"\n    )\n\n    log_level: str = \"INFO\"\n\n    cluster_name: str\n    s3_endpoint: str\n    s3_endpoint_secure: bool = True\n\n    minio_controller_user: str\n    cluster_resources_file: str = \"resources.yaml\"\n\n    secret_backend_type: str\n    secret_backend_s3_bucket: str = \"minio-manager-secrets\"\n    secret_backend_s3_access_key: str\n    secret_backend_s3_secret_key: str\n\n    keepass_filename: str = \"secrets.kdbx\"\n    keepass_password: str | None = None\n\n    auto_create_service_account: bool = True\n    allowed_bucket_prefixes: tuple[str, ...] = ()\n    default_bucket_versioning: str = \"Suspended\"\n    default_lifecycle_policy_file: str | None = None\n    service_account_policy_base_file: str = \"\"\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: CustomEnvSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -&gt; tuple[PydanticBaseSettingsSource, ...]:\n        return (\n            CustomEnvSettingsSource(settings_cls),\n            CustomDotEnvSettingsSource(settings_cls),\n            init_settings,\n        )\n</code></pre> <p>ControllerUser represents the controller user of our application.</p> <p>name: The name of the controller user access_key: The access key of the controller user secret_key: The secret key of the controller user</p> Source code in <code>minio_manager/classes/controller_user.py</code> <pre><code>class ControllerUser:\n    \"\"\"\n    ControllerUser represents the controller user of our application.\n\n    name: The name of the controller user\n    access_key: The access key of the controller user\n    secret_key: The secret key of the controller user\n    \"\"\"\n\n    name: str\n    access_key: str\n    secret_key: str\n\n    def __init__(self, name: str):\n        self.name = name\n        credentials = secrets.get_credentials(name)\n        self.access_key = credentials.access_key\n        self.secret_key = credentials.secret_key\n</code></pre>"},{"location":"modules/#minio_manager.classes.resource_parser.ClusterResources.parse_bucket_lifecycle_file","title":"<code>parse_bucket_lifecycle_file(lifecycle_file)</code>","text":"<p>Parse a bucket lifecycle config file.</p> The config files must be in JSON format and can be best obtained by running the following command <p>mc ilm rule export $cluster/$bucket &gt; $policy_file.json</p> <p>Parameters:</p> Name Type Description Default <code>lifecycle_file</code> <code>str</code> <p>lifecycle config file</p> required <p>Returns: LifecycleConfig object</p> Source code in <code>minio_manager/classes/resource_parser.py</code> <pre><code>def parse_bucket_lifecycle_file(self, lifecycle_file: str) -&gt; LifecycleConfig | None:\n    \"\"\"\n    Parse a bucket lifecycle config file.\n\n    The config files must be in JSON format and can be best obtained by running the following command:\n        mc ilm rule export $cluster/$bucket &gt; $policy_file.json\n\n    Args:\n        lifecycle_file: lifecycle config file\n\n    Returns: LifecycleConfig object\n    \"\"\"\n    if not lifecycle_file:\n        return\n\n    rules: list = []\n\n    try:\n        with Path(lifecycle_file).open() as f:\n            config_data = json.load(f)\n    except FileNotFoundError:\n        logger.error(f\"Lifecycle file {lifecycle_file} not found, skipping configuration.\")\n        sys.exit(1)\n    except PermissionError:\n        logger.error(f\"Incorrect file permissions on {lifecycle_file}, skipping configuration.\")\n        sys.exit(1)\n\n    try:\n        rules_dict = config_data[\"Rules\"]\n    except KeyError:\n        logger.error(f\"Lifecycle file {lifecycle_file} is missing the required 'Rules' key.\")\n        sys.exit(1)\n\n    try:\n        for rule_data in rules_dict:\n            parsed_rule = self.parse_bucket_lifecycle_rule(rule_data)\n            rules.append(parsed_rule)\n    except AttributeError:\n        logger.error(f\"Error parsing lifecycle file {lifecycle_file}. Is the format correct?\")\n        sys.exit(1)\n\n    if not rules:\n        return\n\n    return LifecycleConfig(rules)\n</code></pre>"},{"location":"modules/#minio_manager.classes.resource_parser.ClusterResources.parse_bucket_lifecycle_rule","title":"<code>parse_bucket_lifecycle_rule(rule_data)</code>  <code>staticmethod</code>","text":"<p>Parse a single bucket object lifecycle rule.</p> TODO <p>Implement date and days in Expiration, implement Transition, NoncurrentVersionTransition, Filter, and AbortIncompleteMultipartUpload</p> <p>Parameters:</p> Name Type Description Default <code>rule_data</code> <code>dict</code> <p>dict with rule data</p> required <p>Returns: Rule object</p> Source code in <code>minio_manager/classes/resource_parser.py</code> <pre><code>@staticmethod\ndef parse_bucket_lifecycle_rule(rule_data: dict) -&gt; Rule:\n    \"\"\"\n    Parse a single bucket object lifecycle rule.\n\n    TODO:\n      Implement date and days in Expiration, implement Transition, NoncurrentVersionTransition, Filter, and\n      AbortIncompleteMultipartUpload\n\n    Args:\n        rule_data: dict with rule data\n\n    Returns: Rule object\n    \"\"\"\n    rule_dict = {\"status\": rule_data.get(\"Status\"), \"rule_id\": rule_data.get(\"ID\")}\n\n    expiration = rule_data.get(\"Expiration\")\n    if expiration:\n        expire_delete_marker = expiration.get(\"ExpiredObjectDeleteMarker\")\n        rule_dict[\"expiration\"] = Expiration(expired_object_delete_marker=expire_delete_marker)\n\n    noncurrent_version_expiration = rule_data.get(\"NoncurrentVersionExpiration\")\n    if noncurrent_version_expiration:\n        noncurrent_expire_days = noncurrent_version_expiration.get(\"NoncurrentDays\")\n        rule_dict[\"noncurrent_version_expiration\"] = NoncurrentVersionExpiration(noncurrent_expire_days)\n\n    # An empty filter is required for the rule to be valid\n    rule_dict[\"rule_filter\"] = Filter(prefix=\"\")\n\n    rule = Rule(**rule_dict)\n    return rule\n</code></pre>"},{"location":"modules/#minio_manager.classes.resource_parser.ClusterResources.parse_bucket_policies","title":"<code>parse_bucket_policies(bucket_policies)</code>  <code>staticmethod</code>","text":"<p>Parse a list of bucket policy definitions into BucketPolicy objects.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_policies</code> <code>list</code> <p>list of bucket policies</p> required <p>Returns: [BucketPolicy]</p> Source code in <code>minio_manager/classes/resource_parser.py</code> <pre><code>@staticmethod\ndef parse_bucket_policies(bucket_policies: list):\n    \"\"\"\n    Parse a list of bucket policy definitions into BucketPolicy objects.\n\n    Args:\n        bucket_policies: list of bucket policies\n\n    Returns: [BucketPolicy]\n    \"\"\"\n    if not bucket_policies:\n        logger.debug(\"No bucket policies configured, skipping.\")\n        return []\n\n    bucket_policy_objects = []\n    try:\n        logger.debug(f\"Parsing {len(bucket_policies)} bucket policies...\")\n        for bucket_policy in bucket_policies:\n            bucket_policy_objects.append(BucketPolicy(bucket_policy[\"bucket\"], bucket_policy[\"policy_file\"]))\n    except TypeError:\n        logger.error(\"Bucket policies must be defined as a list of YAML dictionaries!\")\n        sys.exit(1)\n\n    return bucket_policy_objects\n</code></pre>"},{"location":"modules/#minio_manager.classes.resource_parser.ClusterResources.parse_buckets","title":"<code>parse_buckets(buckets)</code>","text":"<p>Parse the provided buckets with the following steps:</p> <p>For each provided bucket</p> <pre><code>1. check the provided versioning. If versioning is not provided, set the default.\n2. check if an object lifecycle JSON file is provided, use the default_bucket_lifecycle_policy, or skip OLM\n3. parse the file and create a LifecycleConfig object for the bucket\n4. create a Bucket object\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>buckets</code> <code>list</code> <p>list of buckets to parse</p> required <p>Returns: [Bucket]: list of Bucket objects</p> Source code in <code>minio_manager/classes/resource_parser.py</code> <pre><code>def parse_buckets(self, buckets: list) -&gt; list[Bucket]:\n    \"\"\"\n    Parse the provided buckets with the following steps:\n\n    For each provided bucket\n\n        1. check the provided versioning. If versioning is not provided, set the default.\n        2. check if an object lifecycle JSON file is provided, use the default_bucket_lifecycle_policy, or skip OLM\n        3. parse the file and create a LifecycleConfig object for the bucket\n        4. create a Bucket object\n\n    Args:\n        buckets: list of buckets to parse\n\n    Returns: [Bucket]: list of Bucket objects\n    \"\"\"\n    if not buckets:\n        logger.debug(\"No buckets configured, skipping.\")\n        return []\n\n    bucket_objects = []\n\n    lifecycle_config = self.parse_bucket_lifecycle_file(settings.default_lifecycle_policy_file)\n    bucket_names = []\n\n    try:\n        logger.debug(f\"Parsing {len(buckets)} buckets...\")\n        if settings.allowed_bucket_prefixes:\n            logger.info(f\"Only allowing buckets with the following prefixes: {settings.allowed_bucket_prefixes}\")\n        for bucket in buckets:\n            name = bucket[\"name\"]\n            if name in bucket_names:\n                logger.error(f\"Bucket '{name}' defined multiple times. Stopping.\")\n                sys.exit(1)\n            logger.debug(f\"Parsing bucket {name}\")\n            allowed_prefixes = settings.allowed_bucket_prefixes\n            if allowed_prefixes and not name.startswith(allowed_prefixes):\n                logger.error(\n                    f\"Bucket '{name}' does not start with one of the required prefixes {allowed_prefixes}!\"\n                )\n                sys.exit(1)\n\n            bucket_names.append(name)\n            versioning = bucket.get(\"versioning\")\n            try:\n                versioning_config = VeCo(versioning) if versioning else VeCo(settings.default_bucket_versioning)\n            except ValueError as ve:\n                logger.error(f\"Error parsing versioning setting: {' '.join(ve.args)}\")\n                sys.exit(1)\n            create_sa = bool(bucket.get(\"create_service_account\", settings.default_bucket_versioning))\n            lifecycle_file = bucket.get(\"object_lifecycle_file\")\n            if lifecycle_file:\n                bucket_lifecycle = self.parse_bucket_lifecycle_file(lifecycle_file)\n                if isinstance(bucket_lifecycle, LifecycleConfig):\n                    lifecycle_config = bucket_lifecycle\n            bucket_objects.append(Bucket(name, create_sa, versioning_config, lifecycle_config))\n    except TypeError:\n        logger.error(\"Buckets must be defined as a list of YAML dictionaries!\")\n        sys.exit(1)\n\n    return bucket_objects\n</code></pre>"},{"location":"modules/#minio_manager.classes.resource_parser.ClusterResources.parse_iam_attachments","title":"<code>parse_iam_attachments(iam_policy_attachments)</code>  <code>staticmethod</code>","text":"<p>Parse a list of IAM policy attachment definitions into IamPolicyAttachment objects.</p> <p>Parameters:</p> Name Type Description Default <code>iam_policy_attachments</code> <code>list</code> <p>dict of IAM policy attachments</p> required <p>Returns: [IamPolicyAttachment]</p> Source code in <code>minio_manager/classes/resource_parser.py</code> <pre><code>@staticmethod\ndef parse_iam_attachments(iam_policy_attachments: list):\n    \"\"\"\n    Parse a list of IAM policy attachment definitions into IamPolicyAttachment objects.\n\n    Args:\n        iam_policy_attachments: dict of IAM policy attachments\n\n    Returns: [IamPolicyAttachment]\n    \"\"\"\n    if not iam_policy_attachments:\n        logger.debug(\"No IAM policy attachments configured, skipping.\")\n        return []\n\n    iam_policy_attachment_objects = []\n    try:\n        logger.debug(f\"Parsing {len(iam_policy_attachments)} IAM policy attachments...\")\n        for user in iam_policy_attachments:\n            iam_policy_attachments.append(IamPolicyAttachment(user[\"username\"], user[\"policies\"]))\n    except TypeError:\n        logger.error(\"IAM policy attachments must be defined as a list of YAML dictionaries!\")\n        sys.exit(1)\n\n    return iam_policy_attachment_objects\n</code></pre>"},{"location":"modules/#minio_manager.classes.resource_parser.ClusterResources.parse_iam_policies","title":"<code>parse_iam_policies(iam_policies)</code>  <code>staticmethod</code>","text":"<p>Parse a list of IAM policy definitions into IamPolicy objects.</p> <p>Parameters:</p> Name Type Description Default <code>iam_policies</code> <code>dict</code> <p>dict of IAM policies</p> required <p>Returns: [IamPolicy]</p> Source code in <code>minio_manager/classes/resource_parser.py</code> <pre><code>@staticmethod\ndef parse_iam_policies(iam_policies: dict):\n    \"\"\"\n    Parse a list of IAM policy definitions into IamPolicy objects.\n\n    Args:\n        iam_policies: dict of IAM policies\n\n    Returns: [IamPolicy]\n    \"\"\"\n    if not iam_policies:\n        logger.debug(\"No IAM policies configured, skipping.\")\n        return []\n\n    iam_policy_objects, iam_policy_names = [], []\n    try:\n        logger.debug(f\"Parsing {len(iam_policies)} IAM policies...\")\n        for iam_policy in iam_policies:\n            name = iam_policy[\"name\"]\n            if name in iam_policy_names:\n                logger.error(f\"IAM policy '{name}' defined multiple times. Stopping.\")\n                sys.exit(1)\n            iam_policy_names.append(name)\n            iam_policy_objects.append(IamPolicy(name, iam_policy[\"policy_file\"]))\n    except TypeError:\n        logger.error(\"IAM policies must be defined as a list of YAML dictionaries!\")\n        sys.exit(1)\n\n    return iam_policy_objects\n</code></pre>"},{"location":"modules/#minio_manager.classes.resource_parser.ClusterResources.parse_resources","title":"<code>parse_resources(resources_file)</code>","text":"<p>Parse resources from a YAML file, ensuring they are valid before trying to use them.</p> <p>Parameters:</p> Name Type Description Default <code>resources_file</code> <code>str</code> <p>string path to the YAML file</p> required Source code in <code>minio_manager/classes/resource_parser.py</code> <pre><code>def parse_resources(self, resources_file: str):\n    \"\"\"\n    Parse resources from a YAML file, ensuring they are valid before trying to use them.\n\n    Args:\n        resources_file: string path to the YAML file\n    \"\"\"\n    logger.info(\"Loading and parsing resources...\")\n\n    try:\n        resources = read_yaml(resources_file)\n    except FileNotFoundError:\n        logger.error(f\"Resources file {resources_file} not found. Stopping.\")\n        sys.exit(1)\n    except PermissionError:\n        logger.error(f\"Incorrect file permissions on {resources_file}. Stopping.\")\n        sys.exit(1)\n\n    if not resources:\n        logger.error(\"Is the resources file empty?\")\n        sys.exit(1)\n\n    buckets = resources.get(\"buckets\")\n    self.buckets = self.parse_buckets(buckets)\n\n    bucket_policies = resources.get(\"bucket_policies\")\n    self.bucket_policies = self.parse_bucket_policies(bucket_policies)\n\n    service_accounts = resources.get(\"service_accounts\")\n    self.service_accounts = self.parse_service_accounts(service_accounts)\n\n    iam_policies = resources.get(\"iam_policies\")\n    self.iam_policies = self.parse_iam_policies(iam_policies)\n\n    iam_policy_attachments = resources.get(\"iam_policy_attachments\")\n    self.iam_policy_attachments = self.parse_iam_attachments(iam_policy_attachments)\n\n    if not any([buckets, bucket_policies, service_accounts, iam_policies, iam_policy_attachments]):\n        logger.warning(\"No resources configured.\")\n        sys.exit(0)\n</code></pre>"},{"location":"modules/#minio_manager.classes.resource_parser.ClusterResources.parse_service_accounts","title":"<code>parse_service_accounts(service_accounts)</code>  <code>staticmethod</code>","text":"<p>Parse a list of service account definitions into ServiceAccount objects.</p> <p>Parameters:</p> Name Type Description Default <code>service_accounts</code> <code>list</code> <p>dict of service accounts</p> required <p>Returns: [ServiceAccount]</p> Source code in <code>minio_manager/classes/resource_parser.py</code> <pre><code>@staticmethod\ndef parse_service_accounts(service_accounts: list):\n    \"\"\"\n    Parse a list of service account definitions into ServiceAccount objects.\n\n    Args:\n        service_accounts: dict of service accounts\n\n    Returns: [ServiceAccount]\n    \"\"\"\n    if not service_accounts:\n        logger.debug(\"No service accounts configured, skipping.\")\n        return []\n\n    service_account_objects, service_account_names = [], []\n\n    try:\n        logger.debug(f\"Parsing {len(service_accounts)} service accounts...\")\n        for service_account in service_accounts:\n            name = service_account[\"name\"]\n            if name in service_account_names:\n                logger.error(f\"Service account '{name}' defined multiple times. Stopping.\")\n                sys.exit(1)\n            service_account_names.append(name)\n            policy_file = service_account.get(\"policy_file\")\n            sa_obj = ServiceAccount(name=name, policy_file=policy_file)\n            service_account_objects.append(sa_obj)\n    except TypeError:\n        logger.error(\"Service accounts must be defined as a list of YAML dictionaries!\")\n        sys.exit(1)\n\n    return service_account_objects\n</code></pre>"},{"location":"modules/#minio_manager.classes.mc_wrapper.McWrapper.cleanup","title":"<code>cleanup()</code>","text":"<p>We want to clean up the mc config file before the process finishes as otherwise it can cause issues with subsequent runs for different environments.</p> Source code in <code>minio_manager/classes/mc_wrapper.py</code> <pre><code>def cleanup(self):\n    \"\"\"\n    We want to clean up the mc config file before the process finishes as otherwise it can cause issues with\n    subsequent runs for different environments.\n    \"\"\"\n    if not self.mc_config_path.name.startswith(\"/tmp\"):  # noqa: S108\n        raise MinioManagerBaseError(\"CleanUpError\", \"Error during cleanup: temporary directory is not in /tmp\")\n    logger.debug(f\"Deleting temporary mc config directory {self.mc_config_path.name}\")\n    self.mc_config_path.cleanup()\n</code></pre>"},{"location":"modules/#minio_manager.classes.mc_wrapper.McWrapper.configure","title":"<code>configure(endpoint, access_key, secret_key, secure)</code>","text":"<p>Ensure the proper alias is configured for the cluster.</p> Source code in <code>minio_manager/classes/mc_wrapper.py</code> <pre><code>def configure(self, endpoint: str, access_key: str, secret_key: str, secure: bool):\n    \"\"\"Ensure the proper alias is configured for the cluster.\"\"\"\n    logger.info(\"Configuring 'mc'...\")\n    url = f\"https://{endpoint}\" if secure else f\"http://{endpoint}\"\n    alias_set_resp = self._run([\"alias\", \"set\", settings.cluster_name, url, access_key, secret_key])\n    if alias_set_resp.get(\"error\"):\n        error_details = alias_set_resp[\"error\"][\"cause\"][\"error\"]\n        try:\n            raise_specific_error(error_details[\"Code\"], error_details[\"Message\"])\n        except AttributeError as ae:\n            logger.exception(\"Unknown error!\")\n            raise MinioManagerBaseError(alias_set_resp[\"error\"][\"cause\"][\"message\"]) from ae\n\n    cluster_ready = self._run([\"ready\", settings.cluster_name])\n    healthy = cluster_ready.get(\"healthy\")\n    if healthy:\n        # Cluster is configured &amp; available\n        return\n\n    if cluster_ready.get(\"error\"):\n        # A connection error occurred\n        raise ConnectionError(cluster_ready[\"error\"])\n</code></pre>"},{"location":"modules/#minio_manager.classes.mc_wrapper.McWrapper.find_mc_command","title":"<code>find_mc_command()</code>  <code>staticmethod</code>","text":"<p>Configure the path to the mc command, as it may be named 'mcli' on some systems.</p> Source code in <code>minio_manager/classes/mc_wrapper.py</code> <pre><code>@staticmethod\ndef find_mc_command() -&gt; Path:\n    \"\"\"Configure the path to the mc command, as it may be named 'mcli' on some systems.\"\"\"\n    mc = shutil.which(\"mc\")\n    if not mc:\n        mc = shutil.which(\"mcli\")\n    return Path(mc)\n</code></pre>"},{"location":"modules/#minio_manager.classes.mc_wrapper.McWrapper.service_account_add","title":"<code>service_account_add(credentials)</code>","text":"<p>mc admin user svcacct add alias-name 'username' --name \"sa-test-key\"</p> <p>Parameters:</p> Name Type Description Default <code>credentials</code> <code>ServiceAccount</code> <p>object containing at least the user-friendly name of the service account</p> required <p>Returns: ServiceAccount with the access and secret keys added to it</p> Source code in <code>minio_manager/classes/mc_wrapper.py</code> <pre><code>def service_account_add(self, credentials: ServiceAccount) -&gt; ServiceAccount:\n    \"\"\"\n    mc admin user svcacct add alias-name 'username' --name \"sa-test-key\"\n\n    Args:\n        credentials (ServiceAccount): object containing at least the user-friendly name of the service account\n\n    Returns: ServiceAccount with the access and secret keys added to it\n    \"\"\"\n    # Create the service account in MinIO\n    args = [settings.minio_controller_user, \"--name\", credentials.name]\n    if credentials.description:\n        args.extend([\"--description\", credentials.description])\n    if credentials.access_key:\n        args.extend([\"--access-key\", credentials.access_key])\n    if credentials.secret_key:\n        args.extend([\"--secret-key\", credentials.secret_key])\n    resp = self._service_account_run(\"add\", args)\n    credentials.access_key = resp[\"accessKey\"]\n    credentials.secret_key = resp[\"secretKey\"]\n    return credentials\n</code></pre>"},{"location":"modules/#minio_manager.classes.mc_wrapper.McWrapper.service_account_delete","title":"<code>service_account_delete()</code>","text":"<p>mc admin user svcacct rm alias-name service-account-access-key</p> Source code in <code>minio_manager/classes/mc_wrapper.py</code> <pre><code>def service_account_delete(self):\n    \"\"\"mc admin user svcacct rm alias-name service-account-access-key\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/#minio_manager.classes.mc_wrapper.McWrapper.service_account_info","title":"<code>service_account_info(access_key)</code>","text":"<p>mc admin user svcacct info alias-name service-account-access-key</p> Source code in <code>minio_manager/classes/mc_wrapper.py</code> <pre><code>def service_account_info(self, access_key: str) -&gt; dict:\n    \"\"\"mc admin user svcacct info alias-name service-account-access-key\"\"\"\n    return self._service_account_run(\"info\", [access_key])\n</code></pre>"},{"location":"modules/#minio_manager.classes.mc_wrapper.McWrapper.service_account_list","title":"<code>service_account_list(access_key)</code>","text":"<p>mc admin user svcacct ls alias-name 'access_key'</p> Source code in <code>minio_manager/classes/mc_wrapper.py</code> <pre><code>def service_account_list(self, access_key: str) -&gt; list[dict]:\n    \"\"\"mc admin user svcacct ls alias-name 'access_key'\"\"\"\n    return self._service_account_run(\"ls\", [access_key])\n</code></pre>"},{"location":"modules/#minio_manager.classes.mc_wrapper.McWrapper.service_account_set_policy","title":"<code>service_account_set_policy(access_key, policy_file)</code>","text":"<p>mc admin user svcacct edit alias-name service-account-access-key --policy policy-file</p> Source code in <code>minio_manager/classes/mc_wrapper.py</code> <pre><code>def service_account_set_policy(self, access_key: str, policy_file: str):\n    \"\"\"mc admin user svcacct edit alias-name service-account-access-key --policy policy-file\"\"\"\n    return self._service_account_run(\"edit\", [access_key, \"--policy\", policy_file])\n</code></pre>"},{"location":"modules/#minio_manager.classes.minio_resources.ServiceAccount.generate_service_account_policy","title":"<code>generate_service_account_policy()</code>","text":"<p>Generate a policy for a service account that gives access to a bucket with the same name as the service account.</p> Source code in <code>minio_manager/classes/minio_resources.py</code> <pre><code>def generate_service_account_policy(self):\n    \"\"\"\n    Generate a policy for a service account that gives access to a bucket with the same name as the service account.\n    \"\"\"\n    if settings.service_account_policy_base_file:\n        with Path(settings.service_account_policy_base_file).open() as base:\n            base_policy = base.read()\n    else:\n        from minio_manager.resources.policies import service_account_policy_base\n\n        base_policy = json.dumps(service_account_policy_base)\n\n    temp_file = NamedTemporaryFile(prefix=self.name, suffix=\".json\", delete=False)\n    with temp_file as out:\n        new_content = base_policy.replace(\"BUCKET_NAME_REPLACE_ME\", self.name)\n        out.write(new_content.encode(\"utf-8\"))\n\n    self.policy = json.loads(new_content)\n    self.policy_file = Path(temp_file.name)\n    self.policy_generated = True\n</code></pre>"},{"location":"modules/#minio_manager.classes.secrets.SecretManager.get_credentials","title":"<code>get_credentials(name, required=False)</code>","text":"<p>Get a password from the configured secret backend.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the password entry</p> required <code>required</code> <code>bool</code> <p>whether the credentials must exist</p> <code>False</code> <p>Returns: MinioCredentials</p> Source code in <code>minio_manager/classes/secrets.py</code> <pre><code>def get_credentials(self, name: str, required: bool = False) -&gt; ServiceAccount:\n    \"\"\"Get a password from the configured secret backend.\n\n    Args:\n        name (str): the name of the password entry\n        required (bool): whether the credentials must exist\n\n    Returns: MinioCredentials\n    \"\"\"\n    method_name = f\"{self.backend_type}_get_credentials\"\n    method = getattr(self, method_name)\n    return method(name, required)\n</code></pre>"},{"location":"modules/#minio_manager.classes.secrets.SecretManager.keepass_get_credentials","title":"<code>keepass_get_credentials(name, required)</code>","text":"<p>Get a password from the configured Keepass database.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the password entry</p> required <code>required</code> <code>bool</code> <p>if the entry must exist</p> required <p>Returns:</p> Type Description <code>ServiceAccount</code> <p>ServiceAccount</p> Source code in <code>minio_manager/classes/secrets.py</code> <pre><code>def keepass_get_credentials(self, name: str, required: bool) -&gt; ServiceAccount:\n    \"\"\"Get a password from the configured Keepass database.\n\n    Args:\n        name (str): the name of the password entry\n        required (bool): if the entry must exist\n\n    Returns:\n        ServiceAccount\n    \"\"\"\n    logger.debug(f\"Finding Keepass entry for {name}\")\n    entry = self.backend.find_entries(title=name, group=self.keepass_group, first=True)\n\n    try:\n        credentials = ServiceAccount(name=name, access_key=entry.username, secret_key=entry.password)\n        logger.debug(f\"Found access key {credentials.access_key}\")\n    except AttributeError as ae:\n        if not ae.obj:\n            if required:\n                logger.critical(f\"Required entry for {name} not found!\")\n                sys.exit(14)\n            return ServiceAccount(name=name)\n        logger.critical(f\"Unhandled exception: {ae}\")\n    else:\n        return credentials\n</code></pre>"},{"location":"modules/#minio_manager.classes.secrets.SecretManager.keepass_set_password","title":"<code>keepass_set_password(credentials)</code>","text":"<p>Set the password for the given credentials.</p> <p>Parameters:</p> Name Type Description Default <code>credentials</code> <code>ServiceAccount</code> <p>the credentials to set</p> required Source code in <code>minio_manager/classes/secrets.py</code> <pre><code>def keepass_set_password(self, credentials: ServiceAccount):\n    \"\"\"Set the password for the given credentials.\n\n    Args:\n        credentials (ServiceAccount): the credentials to set\n    \"\"\"\n    logger.debug(f\"Creating Keepass entry '{credentials.name}' with access key '{credentials.access_key}'\")\n    self.backend.add_entry(\n        destination_group=self.keepass_group,\n        title=credentials.name,\n        username=credentials.access_key,\n        password=credentials.secret_key,\n    )\n</code></pre>"},{"location":"modules/#minio_manager.classes.secrets.SecretManager.retrieve_keepass_backend","title":"<code>retrieve_keepass_backend()</code>","text":"<p>Back-end implementation for the keepass backend. Two-step process:     - first we retrieve the kdbx file from the S3 bucket     - then we configure the PyKeePass backend</p> <p>Returns: PyKeePass object, with the kdbx file loaded</p> Source code in <code>minio_manager/classes/secrets.py</code> <pre><code>def retrieve_keepass_backend(self) -&gt; PyKeePass:\n    \"\"\"Back-end implementation for the keepass backend.\n    Two-step process:\n        - first we retrieve the kdbx file from the S3 bucket\n        - then we configure the PyKeePass backend\n\n    Returns: PyKeePass object, with the kdbx file loaded\n\n    \"\"\"\n    self.backend_filename = settings.keepass_filename\n    tmp_file = NamedTemporaryFile(prefix=f\"mm.{self.backend_filename}.\", delete=False)\n    self.keepass_temp_file = tmp_file\n    try:\n        response = self.backend_s3.get_object(self.backend_bucket, self.backend_filename)\n        with tmp_file as f:\n            logger.debug(f\"Writing kdbx file to temp file {tmp_file.name}\")\n            f.write(response.data)\n    except S3Error as s3e:\n        logger.debug(s3e)\n        logger.critical(\n            f\"Unable to retrieve {self.backend_filename} from {self.backend_bucket}!\\n\"\n            \"Do the required bucket and kdbx file exist, and does the user have the correct \"\n            \"policies assigned?\"\n        )\n        sys.exit(11)\n    finally:\n        response.close()\n        response.release_conn()\n\n    kp_pass = settings.keepass_password\n    logger.debug(\"Opening keepass database\")\n    try:\n        kp = PyKeePass(self.keepass_temp_file.name, password=kp_pass)\n    except CredentialsError:\n        logger.critical(\"Invalid credentials for Keepass database.\")\n        sys.exit(13)\n    # noinspection PyTypeChecker\n    self.keepass_group = kp.find_groups(path=[\"s3\", settings.cluster_name])\n    if not self.keepass_group:\n        logger.critical(\"Required group not found in Keepass! See documentation for requirements.\")\n        sys.exit(12)\n    logger.debug(\"Keepass configured as secret backend\")\n    return kp\n</code></pre>"},{"location":"modules/#minio_manager.classes.secrets.SecretManager.setup_backend","title":"<code>setup_backend()</code>","text":"<p>We dynamically configure the backend depending on the given backend type.</p> Source code in <code>minio_manager/classes/secrets.py</code> <pre><code>def setup_backend(self):\n    \"\"\"We dynamically configure the backend depending on the given backend type.\"\"\"\n    logger.debug(f\"Configuring SecretManager with backend {self.backend_type}\")\n    method_name = f\"retrieve_{self.backend_type}_backend\"\n    method = getattr(self, method_name)\n    return method()\n</code></pre>"},{"location":"resources/","title":"Resources","text":"<p>Resources that should be deployed are to be specified in each environments' <code>resource.yaml</code>.</p> <p>There are currently 5 resources supported; <code>buckets</code>, <code>bucket_policies</code>, <code>service_accounts</code>, <code>iam_policies</code>, and  <code>iam_policy_attachments</code>.</p>"},{"location":"resources/#buckets","title":"Buckets","text":"<p>Buckets are used to organize and store objects.</p> <p>The <code>resource.yaml</code> supports the following properties for <code>buckets</code>:</p> Property Required Description Default Example <code>name</code> YES Specify the name of the bucket None <code>infra-test-tomato-bucket</code> <code>create_service_account</code> NO Do you want to automatically create a service account that has ownership of this bucket? <code>TRUE</code> <code>FALSE</code> <code>object_lifecycle_file</code> NO Specify the lifecycle policy that you want to attach to this bucket None <code>lifecycle_policies/my_lifecycle.json</code> <code>versioning</code> NO Do you want to enable versioning for this bucket? <code>TRUE</code> <code>FALSE</code>"},{"location":"resources/#bucket-policies","title":"Bucket policies","text":"<p>Bucket policies are used to restrict bucket access or action on a bucket level.</p> <p>The <code>resource.yaml</code> supports the following properties for <code>bucket_policies</code>:</p> Property Required Description Default Example <code>name</code> YES Specify the name of the bucket None <code>infra-test-tomato-bucket</code> <code>policy_file</code> YES Specify the name of the policy that should be assigned to the bucket None <code>bucket_policies/my_bucketpolicy.json</code>"},{"location":"resources/#service-accounts","title":"Service accounts","text":"<p>Service accounts are, by default, automatically created when creating a bucket. However, it is possible to create them separately.</p> <p>The <code>resource.yaml</code> supports the following properties for <code>service_accounts</code>:</p> Property Required Description Default Example <code>name</code> YES Specify the name of the service account None <code>infra-test-tomato-bucket</code> <code>policy_file</code> NO Specify the policy file for this service account None <code>user_policies/my_user.json</code>"},{"location":"resources/#iam-policies","title":"IAM policies","text":"<p>IAM policies consist of actions and resources to which an authenticated user has access. Each policy describes one or more actions and conditions that outline the permissions of a user or group of users.</p> <p>The <code>resource.yaml</code> supports the following properties for <code>iam_policies</code>:</p> Property Required Description Default Example <code>name</code> YES Specify the name of the IAM policy None <code>infra-test-adminpolicy</code> <code>policy_file</code> YES Specify the policy file to use for this policy None <code>iam_policies/my_iam.json</code>"},{"location":"resources/#iam-policy-attachment","title":"IAM policy attachment","text":"<p>For IAM policies to be effective we have to attach them to users.</p> <p>The <code>resource.yaml</code> supports the following properties for <code>iam_policy_attachments</code>:</p> Property Required Description Default Example <code>username</code> YES Specify the username which should get a specific policy assigned None <code>my-user</code> <code>policies</code> YES Specify a list of policies to assign to this specific <code>username</code> None <code>policy-1</code>"},{"location":"setup/","title":"Set up","text":"<p>An admin user should be used for these steps.</p>"},{"location":"setup/#steps","title":"Steps","text":"<ol> <li> <p>Create the bucket for the secret backend <code>minio-manager-secrets</code></p> <p><code>mc mb $ALIAS/minio-manager-secrets</code></p> </li> <li> <p>Create a user (either in MinIO or your identity provider)</p> <p>You can use <code>mc admin user add $ALIAS minio-manager</code> for a MinIO user</p> </li> <li> <p>Create a policy that gives read/write access to the bucket for the secret backend</p> <p>You can use the example provided in the <code>examples</code> directory:</p> <p><code>mc admin policy create $ALIAS minio-manager examples/minio-manager-secrets-policy.json</code></p> </li> <li> <p>Attach the policy to the user:</p> </li> <li> <p>For MinIO: <code>mc admin policy attach $ALIAS minio-manager --user=minio-manager</code></p> </li> <li> <p>For LDAP: <code>mc idp ldap policy attach $ALIAS minio-manager --user='uid=minio-manager,cn=users,dc=your,dc=domain'</code></p> </li> <li> <p>Upload your secret backend (e.g. <code>secrets.kdbx</code>) to the bucket root</p> </li> <li> <p>Create a MinIO service account/access key with either option:</p> </li> <li> <p><code>mc admin user svcacct add $ALIAS minio-manager</code> and note down the access and secret keys</p> </li> <li> <p>Copy <code>.env.example</code> to <code>.env</code> and set the following variables to the obtained keys</p> </li> <li> <p><code>MINIO_MANAGER_SECRET_BACKEND_S3_ACCESS_KEY</code></p> </li> <li> <p><code>MINIO_MANAGER_SECRET_BACKEND_S3_SECRET_KEY</code></p> </li> <li> <p>Configure the other variables in the <code>.env</code> file. Descriptions of each variable can be found in the    Environment variables section</p> </li> <li> <p>Each \"bucket group\" manager user must get its own policy.</p> </li> <li>You can find an example in <code>examples/bucket-group-user-policy.json</code></li> <li><code>mc admin policy create $ALIAS infra-test-manager examples/bucket-group-user-policy.json</code></li> <li><code>mc idp ldap policy attach $ALIAS infra-test-manager --user='uid=infra-test-manager,cn=users,dc=your,dc=domain'</code></li> <li>You can then log in to the web console with this user to create an access key exactly like how we did it previously</li> </ol>"},{"location":"setup/#minio","title":"MinIO","text":"<p>At least two users are required in MinIO. One with access to a single bucket containing the secret backend, all other users are to be used as \"bucket group\" managers. For each bucket created under this manager user a service account (or access key in S3/MinIO terms) will be created.</p>"},{"location":"setup/#secret-manager","title":"Secret manager","text":"<p>This is the controller user, that is able to authenticate to the secret backend, in order to retrieve the credentials to the service accounts</p>"},{"location":"setup/#secret-backend","title":"Secret backend","text":"<p>We store our Keepass database inside a MinIO bucket. You can specify the name of this bucket by using the <code>MINIO_MANAGER_SECRET_BACKEND_S3_BUCKET</code> variable. The credentials for this bucket In addition, you have to specify the password of this database with <code>MINIO_MANAGER_SECRET_BACKEND_S3_SECRET_KEY</code>, so that the controller user specified in <code>MINIO_MANAGER_SECRET_BACKEND_S3_ACCESS_KEY</code> can access it.</p> <p>We strongly suggest to pass these variables via masked and/or protected variables.</p>"},{"location":"setup/#service-accounts","title":"Service accounts","text":"<p>Service accounts are used in order to create buckets, they are also the owner of these buckets. By default, we have a one-on-one relationship between service accounts and buckets.</p> <p>However, there is an option to give ownership of multiple bucket to one service account. By specifying <code>create_service_account: False</code> for a bucket in the environment's <code>resource.yaml</code>. You must then specify the ownership through a <code>policy_file</code>:</p> <pre><code>buckets:\n  - name: infra-test-without-sa\n    create_service_account: False\n\nservice_accounts:\n  - name: infra-test-for-multiple-sa\n    policy_file: service_account_policies/infra-test-two-buckets.json\n</code></pre> <p>The Resource section of this json will specify which bucket this service account has ownership of, in this example <code>infra-test-two-buckets.json</code>. The service account will get ownership over 2 buckets and all of its objects:</p> <pre><code>            \"Resource\": [\n                \"arn:aws:s3:::infra-test-without-sa\",\n                \"arn:aws:s3:::infra-test-without-sa/*\",\n                \"arn:aws:s3:::infra-test-multiple-access\",\n                \"arn:aws:s3:::infra-test-multiple-access/*\"\n            ]\n</code></pre>"},{"location":"setup/#keepass","title":"Keepass","text":"<ul> <li>The Keepass database's root group must be named \"Passwords\".</li> <li>You must have a group called \"s3\" and subgroups with the name of each MinIO cluster.</li> <li>Entry names must be unique.</li> <li>Entries are found by way of the title of the entry, the username is not considered when searching.</li> </ul>"},{"location":"setup/#configuration-variables","title":"Configuration variables","text":"<p>See Configuration environment variables</p>"}]}